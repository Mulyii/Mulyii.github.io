
<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8" />
        <title>高质量题解（持续更新中） | Muly&#39;s blog</title>
        <meta name="author" content="晓染" />
        <meta name="description" content="A blog records study of Algorithm, Math and Physics" />
        <meta name="keywords" content="blog" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
        <link rel="icon" href="/images/favicon.png" />
        <script src="https://cdn.staticfile.org/vue/3.2.47/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.3.0/css/all.min.css" />
<link rel="stylesheet" href="/css/fonts.min.css" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.7.0/highlight.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.7.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://cdn.staticfile.org/KaTeX/0.16.4/katex.min.js"></script>
<script src="https://cdn.staticfile.org/KaTeX/0.16.4/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.16.4/katex.min.css" />
<script src="/js/lib/math.js"></script>










<link rel="stylesheet" href="/css/main.css" />

    <meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <div id="layout">
            <transition name="fade">
                <div id="loading" v-show="loading">
                    <div id="loading-circle">
                        <h2>LOADING</h2>
                        <p>加载过慢请开启缓存 浏览器默认开启</p>
                        <img src="/images/loading.gif" />
                    </div>
                </div>
            </transition>
            <nav id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <div id="desktop-menu">
        <a class="title" href="/">
            <span>MULY&#39;S BLOG</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-首页 fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-关于 fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-归档 fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-分类 fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-标签 fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </div>
    <div id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;MULY&#39;S BLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-首页 fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-关于 fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-归档 fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-分类 fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-标签 fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </div>
</nav>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

            <transition name="into">
                <div id="main" v-show="!loading">
                    <div class="article">
    <div>
        <h1>高质量题解（持续更新中）</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/12/22
        </span>
        
        <span class="category">
            <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                算法竞赛
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            <span class="tag">
                
                <a href="/tags/%E9%A2%98%E8%A7%A3/" style="color: #00a596">题解</a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <p><a target="_blank" rel="noopener" href="https://codeforces.com/gym/103446/problem/H">TLife is a Gam</a><br>题目大意: 给定一张$n$个点$m$条边的无向连通图, 每个点拥有点权$a$, 每条边拥有边权$w$. 有$q$次询问, 每次询问给定初始点$x$和初始能力值$k$, 从$x$点出发, 可以通过小于等于当前能力值的边到达另一个点, 每次到达一个未经过的点便获得这个点的点权, 求最大的能力值.</p>
<p>对于任意一张图, 所走过的边一定属于该图的最小生成树, 这一点用Kruskal很容易证明, 对于一条$u, v$的边, 如果点$u$和点$v$已经连通, 这条边的边权一定大于等于$u, v$路径上的所有边的边权.<br>那么这题的一个朴素想法便是构建该图的最小生成树, 对于每次询问, 从$x$出发, 跑一个优先队列维护的bfs即可, 然而时限显然不够.<br>对于这类多次询问的问题的优化, 有两种基本的思路: 其一是对数据进行预处理, 从而降低每次查询的复杂度; 其二是离线查询.<br>对于最小生成树的预处理有 Kruskal 重构树. 我们让重构树的每个点维护其子树的能力增加量和所需的能力值, 从点$x$开始, 一直向上搜索它的父节点, 直到无法向上搜素或者搜索到根节点为止. 但是重构树的高度最坏为$n$, 这意味着每次查询的最坏复杂度为$O(n)$, 还是差点的时限!<br>我们需要再多一点的预处理, 树上的预处理似乎可以用树上倍增来处理. 尝试写一个长度为$2$的转移: $bz[i][1] = max(bz[i][0], bz[fa[i][0]][0])$, 似乎不难理解并且可行, 那么至此此题的最终复杂度$O(qlog\ n)$.</p>
<p>参考代码</p>
<pre><code class="lang-cpp">const int MAXN = 1e5 + 10;
struct EDGE &#123;
    int u, v, w;
    bool operator&lt; (const EDGE &amp;a) const &#123;
        return w &lt; a.w;
    &#125;;
&#125;;
struct DSU &#123;
    int N;
    vector&lt;int&gt; p;
    DSU(int n) &#123;
        N = n;
        p.resize(n);
        for(int i = 0; i &lt; n; i ++) &#123;
            p[i] = i;
        &#125;
    &#125;
    int root(int x) &#123;
        return p[x] == x ? x : p[x] = root(p[x]);
    &#125;
    bool merge(int x, int y) &#123;
        int X = root(x), Y = root(y);
        if(X == Y) return 1;
        p[X] = Y;
        return 0;
    &#125;
&#125;;
struct NODE &#123;
    int f = -1, w = 0;
    ll add = 0;
&#125;;
NODE node[MAXN &lt;&lt; 1];
vector&lt;EDGE&gt; e;
ll bz[MAXN &lt;&lt; 1][17];
int fa[MAXN &lt;&lt; 1][17];
int n, m, q;
int main () &#123;
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;
    e.resize(m);
    vector&lt;int&gt; a(n);
    for(int i = 0; i &lt; n; i ++) &#123;
        cin &gt;&gt; a[i];
        node[i].add = a[i];
    &#125;
    for(auto &amp;[u, v, w] : e) &#123;
        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
        u --, v --;
    &#125;
    sort(e.begin(), e.end());
    DSU dsu(2 * n + 10);
    for(auto &amp;[u, v, w] : e) &#123;
        int U = dsu.root(u), V = dsu.root(v);
        if(U != V) &#123;
            dsu.merge(U, n), dsu.merge(V, n);
            node[U].f = node[V].f = n;
            node[n].add = node[U].add + node[V].add;
            node[n].w = w;
            n ++;
        &#125;
    &#125;
    for(int i = 0; i &lt; n; i ++) &#123;
        fa[i][0] = node[i].f;
        bz[i][0] = node[node[i].f].w - node[i].add;
    &#125;
    for(int i = 1; i &lt; 17; i ++) &#123;
        for(int j = 0; j &lt; n; j ++) &#123;
            if(fa[j][i - 1] == - 1) &#123;
                fa[j][i] = -1;
                continue;
            &#125;
            fa[j][i] = fa[fa[j][i - 1]][i - 1];
            bz[j][i] = max(bz[j][i - 1], bz[fa[j][i - 1]][i - 1]);
        &#125;
    &#125;
    while(q --) &#123;
        int x, k;
        cin &gt;&gt; x &gt;&gt; k;
        x --;
        for(int i = 16; i &gt;= 0; i --) &#123;
            if(fa[x][i] != -1) &#123;
                if(bz[x][i] &lt;= k) &#123;
                    x = fa[x][i];
                &#125;
            &#125;
        &#125;
        ll res = k + node[x].add;
        cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/gym/103446/problem/M">Harmony in Harmony</a><br>题目大意: $n$个人将大小为$1$的地均分两次, 第一次每人分得$1/n$, 第二次同样分为大小相同的$n$份, $n$人自行分配, 要求使得第一次和第二次区域的交集最小的人的值最大, 第二次均分地时有一种分法, 使得这个值最小, 求出这个值.</p>
<p>首先可以猜测此题的答案存在一个上界$\frac{1}{n^2}$. 可以将此过程看作一个完全二分图匹配, 我们可以列出一个$n\times n$的表格, 其中每行的值之和为$\frac{1}{n}$, 每列的值之和为$1$, 所求的值为表格中坐标为 $(i, i)$ 的最小值. 我们假定 $(i, i)$ 为我们要找的最小值, 那么为了让这个值最小, 可以让 $\sum_{k = 1}^{i - 1}(k, i)$ 最大, 又因为要让每人分得的土地最大, 可以让前$i-1$个人分得的土地一样大都为$\frac{1}{in}$, 那么$i$分得的土地大小应为$\frac{\frac{1}{n}-\frac{i-1}{in}}{n-i+1}$, 验证此值小于等于$\frac{1}{n^2}$, 故枚举 $i$ 求出答案.</p>
<p>参考代码:</p>
<pre><code class="lang-cpp">int main () &#123;
    int n;
    scanf(&quot;%d&quot;, &amp;n);
    double res = 1;
    for(int i = 0; i &lt;= n; i ++) &#123;
        res = min(res, 1.0 / (n * (n + 1 - i) * i));
    &#125;
    printf(&quot;%.9f&quot;, res);
&#125;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/gym/103470/problem/D">Paimon Sorting</a><br>题目大意: 给出一种$n^2$的排序方式, 询问数组长度为$k$时, 在排序的过程中交换了几次$k\in [1, n]$.<br>假设我们已经知道长度为$x$的结果, 那么怎么样可以推出$x + 1$的结果就是此题的关键. 设已经出现的最大值为$mx$, 考虑下面几种情况: $a[x] &lt; mx$; $a[x] = mx$; $a[x] &gt; mx$.<br>首先考虑第一种情况, 注意到该排序每轮是将最大值交换到$i$位置, 因此对于这种情况只需要考虑最后一轮, 从$1$到$x$位置,每次遇到大于$a[x]$的数便交换, 实际交换的次数为大于$a[x]$的数的集合的大小.<br>其次考虑第三种情况, 首先$a[x]$会走所有前一个最大值所有经过的路径, 此过程的价值为$0$, 其次$a[x]$ 会被移动到$1$位置, 再被移动到$x$位置, 此段的价值为 $2$.<br>最后考虑第二中情况, 显然它本身的价值应该为$0$, 但是它会对下一个 mx 移动到末位置产生阻碍(增加那一段的价值).这段增量为此时的位置到下一个mx位置的长度.</p>
<p>参考代码:</p>
<pre><code class="lang-cpp">struct BIT &#123;
    int N;
    vector&lt;int&gt; c;
    BIT(int n) &#123;
        N = n;
        c.resize(N);
    &#125;;
    void add(int x) &#123;
        for(int i = x; i &lt; N; i += (i &amp; (-i))) &#123;
            c[i] += 1;
        &#125;
    &#125;
    ll sum(int x) &#123;
        ll res = 0;
        for(int i = x; i; i -= (i &amp; (-i))) &#123;
            res += c[i];
        &#125;
        return res;
    &#125;
    ll sum(int l, int r) &#123;
        return sum(r) - sum(l - 1);
    &#125;
&#125;;
void solve() &#123;
    int n;
    cin &gt;&gt; n;
    vector&lt;int&gt; a(n);
    for(int i = 0; i &lt; n; i ++) &#123;
        cin &gt;&gt; a[i];
    &#125;
    ll res = 0;
    BIT bit(n + 10);
    vector&lt;int&gt; tol(n + 1);
    int len = -2;
    int mx = 0;
    for(int i = 0; i &lt; n; i ++) &#123;
        if(mx &lt; a[i]) &#123;
            res += 2 + len;
            mx = a[i];
            len = 0;
        &#125; else if(mx == a[i]) &#123;
            len ++;
        &#125; else &#123;
            if(len) len ++;
        &#125;
        res += bit.sum(a[i] + 1, n + 5);
        if(!tol[a[i]]) &#123;
            tol[a[i]] = 1;
            bit.add(a[i]);
        &#125;
        cout &lt;&lt; res;
        if(i == n - 1) &#123;
            cout &lt;&lt; &#39;\n&#39;;
        &#125; else &#123;
            cout &lt;&lt; &#39; &#39;;
        &#125;
    &#125;
&#125;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/gym/104114/problem/E">Exercise</a><br>题目大意: 给定$2n$个数, 原本(1, 2), (3, 4) … 是一组, 现在要重新分组, 但不能维持原来的组, 问重新分组后每组两个值差的绝对值和的最小值.<br>显然从小到大排序之后, 相邻的两个数分为一个组会使得绝对值和最小, 但不一定符合条件, 于是我们希望能通过某种方法使得所有不合法的组都合法.<br>发现需要被最优的重组方式一定是与相邻的组进行重组, 且增量为$2(p<em>{i + 1,l} - p</em>{i,r})$.<br>可以考虑一种这样的DP, $dp_{i,j}$, 其中$i$表示考虑到第$i$组, $j$表示该组是否需要被重组.<br>可以写出转移方程: </p>
<script type="math/tex; mode=display">
\begin{matrix}
    dp_{i, 1} = dp_{i-1, 0}\\
    dp_{i, 0} = min(dp_{i-1,0},\ dp_{i,0},\ dp_{i,1} + 2(p_{i + 1,l} - p_{i,r}))
\end{matrix}</script><p>参考代码:</p>
<pre><code class="lang-cpp">const ll INF = (1ll &lt;&lt; 60);
struct PAIR &#123;
    ll l, r;
    bool bad = 0;
&#125;;
void solve() &#123;
    int n;
    cin &gt;&gt; n;
    vector&lt;PII&gt; a(2 * n);
    for(int i = 0; i &lt; 2 * n; i ++) &#123;
        cin &gt;&gt; a[i].first;
        a[i].second = i + 1;
    &#125;
    sort(a.begin(), a.end());
    ll res = 0;
    vector&lt;PAIR&gt; p(n);
    for(int i = 0; i &lt; n; i ++) &#123;
        p[i].l = a[2 * i].first;
        p[i].r = a[2 * i + 1].first;
        res += p[i].r - p[i].l;
        int mx = max(a[2 * i].second, a[2 * i + 1].second);
        int mi = min(a[2 * i].second, a[2 * i + 1].second);
        if(mx - 1 == mi &amp;&amp; (mx % 2 == 0)) &#123;
            p[i].bad = 1;
        &#125;
    &#125;
    vector&lt;array&lt;ll, 2&gt;&gt; dp(n);
    dp[0][0] = dp[0][1] = INF;
    dp[0][p[0].bad] = 0;
    for(int i = 1; i &lt; n; i ++) &#123;
        dp[i][0] = dp[i][1] = INF;
        dp[i][p[i].bad] = dp[i - 1][0];
        dp[i][0] = min(dp[i][0], min(dp[i - 1][0], dp[i - 1][1]) + 2 * (p[i].l - p[i - 1].r));
    &#125;
    res += dp[n - 1][0];
    cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/gym/104114/problem/F">Fortune over Sportsmanship</a><br>题目大意: $n$人参见一个网球比赛, 一个$n\times n$的方格表示$(i, j)$进行比赛时收获的人气, 比赛总共进行$n - 1$轮, 胜方获得败方的人气(二者取max), 且败方淘汰出局.现在希望求出比赛可能收获的人气最大值, 并找出赛程.</p>
<p>考虑一种贪心的过程, 每次使当前状态下人气最大的两名选手进行比赛, 因为会继承败方的人气, 所以无论哪名选手淘汰都没关系. 可以用优先队列来模拟比赛.</p>
<p>参考代码:</p>
<pre><code class="lang-cpp">struct Z &#123;
    int val;
    int x, y;
    bool operator&lt; (const Z &amp;a) const &#123;
        if(val != a.val) &#123;
            return val &lt; a.val;
        &#125; else &#123;
            return x &lt; y;
        &#125;
    &#125;
&#125;;
void solve() &#123;
    int n;
    cin &gt;&gt; n;
    ll res = 0;
    vector&lt;vector&lt;int&gt;&gt; p(n, vector&lt;int&gt; (n));
    vector&lt;bool&gt; over(n);
    vector&lt;PII&gt; op;
    for(int i = 0; i &lt; n; i ++) &#123;
        for(int j = 0; j &lt; n; j ++) &#123;
            cin &gt;&gt; p[i][j];
        &#125;
    &#125;
    priority_queue&lt;Z&gt; q;
    for(int i = 0; i &lt; n; i ++) &#123;
        for(int j = i + 1; j &lt; n; j ++) &#123;
            q.push(&#123;p[i][j], i, j&#125;);
        &#125;
    &#125;
    while(q.size()) &#123;
        int v = q.top().val;
        int x = q.top().x;
        int y = q.top().y;
        q.pop();
        if(!over[x] &amp;&amp; !over[y]) &#123;
            op.push_back(&#123;x, y&#125;);
            res += v;
            over[y] = 1;
            for(int i = 0; i &lt; n; i ++) &#123;
                if(over[i] || i == x) continue;
                p[i][x] = p[x][i] = max(p[x][i], p[y][i]);
                q.push(&#123;p[x][i], min(x, i), max(x ,i)&#125;);
            &#125;
        &#125;
    &#125;
    cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    for(auto &amp;[x, y] : op) &#123;
        cout &lt;&lt; x + 1 &lt;&lt; &#39; &#39; &lt;&lt; y + 1 &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1772/problem/G">Gaining Rating</a><br>题目大意: Monocarp 想提高自己在某下棋网站上的rating, 希望从$x$上升到$y$. 现在有$n$个对手, 每个对手有相应的rating $a_i$, rating 变化的规则为, 获胜加$1$, 失败减$1$但是对手的rating不变, Monocarp 只能下赢rating不大于自己的对手, 同时他可以自己挑选对手, 但是任意两个对手进行对弈的次数差不能大于$1$. 问需要多少轮才能达到目标或者说是不可能的.</p>
<p>显然, 首先需要对所有对手的rating进行一次排序. 我们考虑模拟一轮获得增量, 首先能够赢过$t$个人, 再败给$n-t$个人, 一轮总共获得的分数为$2t-n$, 如果距离所需达成的最终目标小于等于$t$时, 我们便可以不进入下一轮, 反之, 如果这一轮获得的分数小于等于$0$时, 无论如何都无法达到目标. 我们考虑如何求出$t$, 显然直接对$a$进行upper_bound是错误的, 因为我们的分数是在变化的. 可以考虑维护一个$b_i = a_i - i$表示想一路赢到$i$所需的最小rating. 但是这样的$b$不是单调的, 我们将不单调的$b_i$向下合并, 并增设权值, 这样我们得到了一个可以$log$求出$t$的数组.</p>
<pre><code class="lang-cpp">sort(a.begin(), a.end());
vector&lt;ll&gt; b = a;
for(int i = 0; i &lt; n; i ++) &#123;
    b[i] -= i;
&#125;
vector&lt;int&gt; s(1, 1);
vector&lt;ll&gt; v(1, b[0]);
for(int i = 1; i &lt; n; i ++) &#123;
    if(b[i] &lt;= v.back()) &#123;
        s.back() ++;
    &#125; else &#123;
        v.push_back(b[i]);
        s.push_back(1);
    &#125;
&#125;
v.push_back(1e18);
for(int i = 1; i &lt; s.size(); i ++) &#123;
    s[i] += s[i - 1];
&#125;
</code></pre>
<p>上述代码中$v$表示所说的单调数组, $s$表示增量, 接下来我们还不能一下子求出最后的答案, 我们将$v$中数值的大小视为分段的分界线, 已经知道了当前一轮所获得的增量, 我们要判断增量发生变化的值与$y-s_i$哪一个先到, 依次模拟每个分段便能求出最后的答案.</p>
<p>参考代码:</p>
<pre><code class="lang-cpp">void solve() &#123;
    int n;
    ll x, y;
    cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;
    vector&lt;ll&gt; a(n);
    for(int i = 0; i &lt; n; i ++) &#123;
        cin &gt;&gt; a[i];
    &#125;
    sort(a.begin(), a.end());
    vector&lt;ll&gt; b = a;
    for(int i = 0; i &lt; n; i ++) &#123;
        b[i] -= i;
    &#125;
    vector&lt;int&gt; s(1, 1);
    vector&lt;ll&gt; v(1, b[0]);
    for(int i = 1; i &lt; n; i ++) &#123;
        if(b[i] &lt;= v.back()) &#123;
            s.back() ++;
        &#125; else &#123;
            v.push_back(b[i]);
            s.push_back(1);
        &#125;
    &#125;
    v.push_back(1e18);
    for(int i = 1; i &lt; s.size(); i ++) &#123;
        s[i] += s[i - 1];
    &#125;
    for(int i = 1; i &lt; s.size(); i ++) &#123;
        s[i] += s[i - 1];
    &#125;
    ll res = 0;
    while(1) &#123;
        int i = upper_bound(v.begin(), v.end(), x) - v.begin();
        if(!i) &#123;
            cout &lt;&lt; -1 &lt;&lt; &#39;\n&#39;;
            return ;
        &#125;
        if(x + s[i - 1] &gt;= y) &#123;
            cout &lt;&lt; res + y - x &lt;&lt; &#39;\n&#39;;
            return ;
        &#125; else &#123;
            int add = 2 * s[i - 1] - n;
            if(add &lt;= 0) &#123;
                cout &lt;&lt; -1 &lt;&lt; &#39;\n&#39;;
                return;
            &#125; else &#123;
                ll ter = min(y - s[i - 1], v[i]);
                ll cnt = (teg - x + add - 1) / add;
                res += cnt * n;
                x += cnt * add;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1754/problem/F">https://codeforces.com/contest/1754/problem/F</a><br><a target="_blank" rel="noopener" href="https://codeforces.com/contest/822/problem/C">https://codeforces.com/contest/822/problem/C</a><br><a target="_blank" rel="noopener" href="https://codeforces.com/contest/229/problem/D">https://codeforces.com/contest/229/problem/D</a><br><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1288/problem/D">https://codeforces.com/contest/1288/problem/D</a><br><a target="_blank" rel="noopener" href="https://codeforces.com/gym/104114/problem/G">https://codeforces.com/gym/104114/problem/G</a><br><a target="_blank" rel="noopener" href="https://codeforces.com/gym/103446/problem/J">https://codeforces.com/gym/103446/problem/J</a><br><a target="_blank" rel="noopener" href="https://codeforces.com/gym/103470/problem/I">https://codeforces.com/gym/103470/problem/I</a></p>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/gym/103447/problem/G">https://codeforces.com/gym/103447/problem/G</a><br><a target="_blank" rel="noopener" href="https://codeforces.com/gym/104023/problem/J">https://codeforces.com/gym/104023/problem/J</a><br><a target="_blank" rel="noopener" href="https://codeforces.com/gym/104023/problem/D">https://codeforces.com/gym/104023/problem/D</a></p>

    </div>
    
    
    
    
    
    
    
</div>

                    <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2023 - 2023 Muly&#39;s blog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;晓染
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

                </div>
            </transition>
            
        </div>
        <script src="/js/main.js"></script>
        
        




        
    </body>
</html>
