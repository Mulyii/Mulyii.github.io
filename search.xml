<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2022CCPC河南省赛题解</title>
    <url>/2022/10/20/2022CCPC%E6%B2%B3%E5%8D%97%E7%9C%81%E8%B5%9B%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/gym/103941">传送门</a></p>
<h3 id="A-Mocha-上小班啦"><a href="#A-Mocha-上小班啦" class="headerlink" title="A Mocha 上小班啦"></a>A Mocha 上小班啦</h3><p>签到，交换$01$位置输出即可。</p>
<pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
typedef pair&lt;int, int&gt; PII;
const int INF = 1e9 + 7, MAXN = 2e5 + 10, mod = 998244353;
string tab = &quot;1023456789&quot;;
int main() &#123;
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n;
    cin &gt;&gt; n;
    if(n &gt; tab.size()) &#123;
        cout &lt;&lt; &quot;-1\n&quot;;
    &#125; else &#123;
        for(int i = 0; i &lt; n; i ++) &#123;
            cout &lt;&lt; tab[i];
        &#125;
        cout &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;
</code></pre>
<h3 id="B-Hash"><a href="#B-Hash" class="headerlink" title="B Hash"></a>B Hash</h3><p>考虑子串的长度不大于$15$的情况(官方题解说只要考虑这种情况就行了)，然后dp就行了。只需证明长度为$16$的字串必然会存在一个划分使得产生的价值大于不划分产生的价值。具体看官方题解吧，这个证明我也说不太清（现场的话应该可以猜字串长度不会太大来做）。</p>
<pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
typedef pair&lt;int, int&gt; PII;
const int INF = 1e9 + 7, MAXN = 2e5 + 10, mod = 998244353;
int mp(char x) &#123;
    int res = 0;
    if(x == &#39;a&#39;) res = 1;
    else if(x == &#39;e&#39;) res = 2;
    else if(x == &#39;h&#39;) res = 3;
    else if(x == &#39;n&#39;) res = 4;
    return res;
&#125;
int main() &#123;
    ios::sync_with_stdio(false);
    cin.tie(0);
    string s;
    cin &gt;&gt; s;
    int n = s.size();
    s = s + s;
    vector&lt;ll&gt; d(16);
    for(int i = 0; i &lt; 16; i ++) &#123;
        if(!i) d[i] = 1;
        else d[i] = 31 * d[i - 1];
        d[i] %= mod;
    &#125;
    ll res = 0;
    for(int l = 1; l &lt;= 15; l ++) &#123;
        int r = l + n;
        vector&lt;ll&gt; dp (n + 1);
        for(int i = 1; i &lt;= n; i ++) &#123;
            ll t = 0;
            for(int j = i, x = 0; j &gt; max(0, i - 15); j --, x ++) &#123;
                t += mp(s[l + j - 1]) * d[x];
                t %= mod;
                dp[i] = max(dp[i], dp[j - 1] + t);
            &#125;
        &#125;
        res = max(res, dp[n]);
    &#125;
    cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre>
<h3 id="E-Serval-的俳句"><a href="#E-Serval-的俳句" class="headerlink" title="E Serval 的俳句"></a>E Serval 的俳句</h3><p>记录每个字母出现的位置，考虑三段组成的字母，第一段取字母的前5个并记录最后一个字母的位置，第二段找到从记录的位置开始，取7个，再记录最后一个字母的位置，第三段同理。时间复杂度$O(26^3log|S|)$。</p>
<pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
typedef pair&lt;int, int&gt; PII;
const int INF = 1e9 + 7, MAXN = 2e5 + 10, mod = 998244353;

int main() &#123;
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n;
    cin &gt;&gt; n;
    string s;
    cin &gt;&gt; s;
    vector&lt;vector&lt;int&gt;&gt; pos(26);
    for(int i = 0; i &lt; n; i ++) &#123;
        pos[s[i] - &#39;a&#39;].push_back(i);
    &#125;
    for(int i = 0; i &lt; 26; i ++) if(pos[i].size() &gt;= 5) &#123;
        int x1 = 4;
        for(int j = 0; j &lt; 26; j ++) &#123;
            int c = upper_bound(pos[j].begin(), pos[j].end(), pos[i][x1]) - pos[j].begin();
            if(pos[j].size() - c &lt; 7) &#123;
                continue;
            &#125;
            int x2 = c + 6;
            for(int k = 0; k &lt; 26; k ++) &#123;
                int c = upper_bound(pos[k].begin(), pos[k].end(), pos[j][x2]) - pos[k].begin();
                if(pos[k].size() - c &lt; 5) &#123;
                    continue;
                &#125;
                int x3 = c + 4;
                char x = &#39;a&#39; + i, y = &#39;a&#39; + j, z = &#39;a&#39; + k;
                for(int t = 0; t &lt; 5; t ++) &#123;
                    cout &lt;&lt; x;
                &#125;
                for(int t = 0; t &lt; 7; t ++) &#123;
                    cout &lt;&lt; y;
                &#125;
                for(int t = 0; t &lt; 5; t ++) &#123;
                    cout &lt;&lt; z;
                &#125;
                cout &lt;&lt; &#39;\n&#39;;
                return 0;
            &#125;

        &#125;
    &#125;
    cout &lt;&lt; &quot;none\n&quot;;
    return 0;
&#125;
</code></pre>
<h3 id="F-集合之和"><a href="#F-集合之和" class="headerlink" title="F 集合之和"></a>F 集合之和</h3><p>这题卡了很久，以为要求使$n$最小。。。<br>如果是一个等差数列的话，矩阵中的任意一点的值为$O(2a_0 + (i + j)k)$，发现$n$大小的数列能够产生$2n - 1$个不同的数，故对所有的奇数都成立。若前三个数不等差，那么会产生$6$个数，后面每多一个数与前一个数等差，会多产生两个数，故对于所有大于等于$6$的偶数都有解。</p>
<pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
typedef pair&lt;int, int&gt; PII;
const int INF = 1e9 + 7, MAXN = 2e5 + 10, mod = 998244353;

int main() &#123;
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n;
    cin &gt;&gt; n;
    if(n % 2 == 1) &#123;
        int x = (n + 1) / 2;
        cout &lt;&lt; x &lt;&lt; &#39;\n&#39;;
        for(int i = 1; i &lt;= x; i ++) &#123;
            cout &lt;&lt; i &lt;&lt; &#39; &#39;;
        &#125;
        cout &lt;&lt; &#39;\n&#39;;
    &#125; else &#123;
        if(n &gt;= 6) &#123;
            int x = n / 2;
            cout &lt;&lt; x &lt;&lt; &#39;\n&#39;;
            for(int i = 1, j = 1; j &lt;= x; i ++, j ++) &#123;
                if(i == 2) &#123;
                    i ++;
                &#125;
                cout &lt;&lt; i &lt;&lt; &#39; &#39;;
            &#125;
        &#125; else &#123;
            cout &lt;&lt; &quot;-1\n&quot;;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="G-Mocha-上大班啦"><a href="#G-Mocha-上大班啦" class="headerlink" title="G Mocha 上大班啦"></a>G Mocha 上大班啦</h3><p>诈骗题。&amp;运算只会使$0$减少，不会增加，那么对全部数进行&amp;运算就是求每一位都为$1$的个数。</p>
<pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
typedef pair&lt;int, int&gt; PII;
const int INF = 1e9 + 7, MAXN = 2e5 + 10, mod = 998244353;
int main() &#123;
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    vector&lt;vector&lt;int&gt;&gt; v(n, vector&lt;int&gt; (m));
    for(int i = 0; i &lt; n; i ++) &#123;
        string s;
        cin &gt;&gt; s;
        for(int j = 0; j &lt; m; j ++) &#123;
            v[i][j] = s[j] - &#39;0&#39;;
        &#125;
    &#125;
    struct OP &#123;
        int i, j, l, r, p;
    &#125;;
    int q;
    cin &gt;&gt; q;
    vector&lt;OP&gt; op(q);
    for(auto &amp;[i, j, l, r, p] : op) &#123;
        cin &gt;&gt; i &gt;&gt; j &gt;&gt; l &gt;&gt; r &gt;&gt; p;
    &#125;
    int res = 0;
    for(int i = 0; i &lt; m; i ++) &#123;
        int c = 1;
        for(int j = 0; j &lt; n; j ++) &#123;
            c &amp;= v[j][i];
        &#125;
        res += c;
    &#125;
    cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre>
<h3 id="H-旋转水管"><a href="#H-旋转水管" class="headerlink" title="H 旋转水管"></a>H 旋转水管</h3><p>dfs模拟，分类讨论即可, 根据当前位置的水管形状以及上一位置水管的方向来判断下一位置的方向, 时间复杂度$O(m)$。</p>
<pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
typedef pair&lt;int, int&gt; PII;
const int INF = 1e9 + 7, MAXN = 1e5 + 10, mod = 998244353;
int m, s, t;
char G[2][MAXN];
bool vis[3][MAXN];
/*
0 向下
1 向上
2 向左
3 向右
*/
bool res = 0;
void dfs(int x, int y, int type) &#123;
    if(vis[x][y]) &#123;
        return;
    &#125;
    if(x &lt; 0 || x &gt;= 2 || y &lt; 0 || y &gt;= m) &#123;
        if(x == 2 &amp;&amp; y == t) &#123;
            res = 1;
        &#125;
        return;
    &#125;
    vis[x][y] = 1;
    if(type == 1) &#123;
        if(G[x][y] == &#39;I&#39;) &#123;
            dfs(x + 1, y, type);
        &#125; else &#123;
            if(y &gt;= 1)
                dfs(x, y - 1, 2);
            dfs(x, y + 1, 3);
        &#125;
    &#125; else if(type == 2) &#123;
        if(G[x][y] == &#39;I&#39;) &#123;
            if(y &gt;= 1)
                dfs(x, y - 1, type);
        &#125; else &#123;
            if(x &gt;= 1)
                dfs(x - 1, y, 0);
            dfs(x + 1, y, 1);
        &#125;
    &#125; else if(type == 3) &#123;
        if(G[x][y] == &#39;I&#39;) &#123;
            dfs(x, y + 1, type);
        &#125; else &#123;
            if(x &gt;= 1)
                dfs(x - 1, y, 0);
            dfs(x + 1, y, 1);
        &#125;
    &#125; else &#123;
        if(G[x][y] == &#39;I&#39;) &#123;
            if(x &gt;= 1)
                dfs(x - 1, y, type);
        &#125; else &#123;
            if(y &gt;= 1)
                dfs(x, y - 1, 2);
            dfs(x, y + 1, 3);
        &#125;
    &#125;
    vis[x][y] = 0;
&#125;
void solve() &#123;
    cin &gt;&gt; m &gt;&gt; s &gt;&gt; t;
    s --, t --;
    for(int i = 0; i &lt; 2; i ++) &#123;
        for(int j = 0; j &lt; m; j ++) &#123;
            cin &gt;&gt; G[i][j];
        &#125;
    &#125;
    res = 0;
    dfs(0, s, 1);
    if(res) &#123;
        cout &lt;&lt; &quot;YES\n&quot;;
    &#125; else &#123;
        cout &lt;&lt; &quot;NO\n&quot;;
    &#125;
&#125;
int main() &#123;
    ios::sync_with_stdio(false);
    cin.tie(0);
    int _ = 1;
    cin &gt;&gt; _;
    while(_ --) &#123;
        solve();
    &#125;
    return 0;
&#125;
</code></pre>
<h3 id="I-Oshwiciqwq-的电梯"><a href="#I-Oshwiciqwq-的电梯" class="headerlink" title="I Oshwiciqwq 的电梯"></a>I Oshwiciqwq 的电梯</h3><p>大模拟，由于数据范围非常的小，可以确定每一秒的状态。</p>
<p>代码写得又臭又长，好在写了注释，应该可以看懂。</p>
<pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
typedef pair&lt;int, int&gt; PII;
const int INF = 1e9 + 7, MAXN = 2e5 + 10, mod = 998244353;
PII t[3][10][10];   // 0  X, 1  Y ,2  Z; first 位置， second 编号
int v[510];         // 0 未上电梯，1在x电梯上，2在y电梯上，3在z电梯上
struct P &#123;
    int tim;        // 出现时间
    int x, y, z;    // 当前位置
    int tx, ty, tz; // 目标位置
&#125; p[60]; 
int n, m, h, q, k;
void work() &#123;
    for(int i = 1; i &lt;= m; i ++) &#123;
        for(int j = 1; j &lt;= h; j ++) &#123;
            if(t[0][i][j].first &gt; 0) &#123;
                t[0][i][j].first %= n;
                t[0][i][j].first ++;
            &#125;
        &#125;
    &#125;
    for(int i = 1; i &lt;= n; i ++) &#123;
        for(int j = 1; j &lt;= h; j ++) &#123;
            if(t[1][i][j].first &gt;= 0) &#123;
                t[1][i][j].first %= m;
                t[1][i][j].first ++;
            &#125;
        &#125;
    &#125;
    for(int i = 1; i &lt;= n; i ++) &#123;
        for(int j = 1; j &lt;= m; j ++) &#123;
            if(t[2][i][j].first &gt;= 0) &#123;
                t[2][i][j].first %= h;
                t[2][i][j].first ++;
            &#125;
        &#125;
    &#125;
&#125;
struct RES &#123;
    int tt;
    int p;
    int io;
    int xl;
    int x, y, z;
    const bool operator &lt; (const RES&amp; a) const &#123;
        if(tt != a.tt) return tt &lt; a.tt;
        if(xl != a.xl) return xl &lt; a.xl;
        if(io != a.io) return io &lt; a.io;
        if(p != a.p) return p &lt; a.p;
    &#125;
&#125;;
vector&lt;RES&gt; res;
int main() &#123;
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; h &gt;&gt; k;
    for(int i = 0; i &lt; k; i ++) &#123;
        int type, ex, ey, ez;
        cin &gt;&gt; type &gt;&gt; ex &gt;&gt; ey &gt;&gt; ez;
        if(type == 0) &#123;
            t[type][ey][ez].first = ex;
            t[type][ey][ez].second = i;
        &#125; else if(type == 1) &#123;
            t[type][ex][ez].first = ey;
            t[type][ex][ez].second = i;
        &#125; else &#123;
            t[type][ex][ey].first = ez;
            t[type][ex][ey].second = i;
        &#125;
    &#125;
    cin &gt;&gt; q;
    for(int i = 0; i &lt; q; i ++) &#123;
        auto &amp;[tim, x, y, z, tx, ty, tz] = p[i];
        cin &gt;&gt; tim &gt;&gt; x &gt;&gt; y &gt;&gt; z &gt;&gt; tx &gt;&gt; ty &gt;&gt; tz;
    &#125;
    int tt = 0; // 当前时间戳
    bool ok = 0;
    do &#123;
        ok = 0;
        for(int i = 0; i &lt; q; i ++) &#123;
            if(p[i].tim &lt;= tt) &#123;
                // 未进电梯
                if(v[i] == 0) &#123;
                    if(p[i].x != p[i].tx) &#123;
                        ok = 1;
                        if(t[0][p[i].y][p[i].z].first == p[i].x) &#123;
                            res.push_back(&#123;tt, i + 1, 1 , t[0][p[i].y][p[i].z].second + 1, p[i].x, p[i].y, p[i].z&#125;);
                            v[i] = 1;
                            p[i].x %= n;
                            p[i].x ++;
                        &#125;
                    &#125; else if(p[i].y != p[i].ty) &#123;
                        ok = 1;
                        if(t[1][p[i].x][p[i].z].first == p[i].y) &#123;
                            res.push_back(&#123;tt, i + 1, 1 , t[1][p[i].x][p[i].z].second + 1, p[i].x, p[i].y, p[i].z&#125;);
                            v[i] = 2;
                            p[i].y %= m;
                            p[i].y ++;
                        &#125;
                    &#125; else if(p[i].z != p[i].tz) &#123;
                        ok = 1;
                        if(t[2][p[i].x][p[i].y].first == p[i].z) &#123;
                            res.push_back(&#123;tt, i + 1, 1 , t[2][p[i].x][p[i].y].second + 1, p[i].x, p[i].y, p[i].z&#125;);
                            v[i] = 3;
                            p[i].z %= h;
                            p[i].z ++;
                        &#125;
                    &#125;
                &#125; else if(v[i] == 1) &#123;
                    ok = 1;
                    if(p[i].x == p[i].tx) &#123;
                        res.push_back(&#123;tt, i + 1, 0, t[0][p[i].y][p[i].z].second + 1, p[i].x, p[i].y, p[i].z&#125;);
                        v[i] = 0;
                    &#125; else &#123;
                        p[i].x %= n;
                        p[i].x ++;
                    &#125;
                &#125; else if(v[i] == 2) &#123;
                    ok = 1;
                    if(p[i].y == p[i].ty) &#123;
                        res.push_back(&#123;tt, i + 1, 0, t[1][p[i].x][p[i].z].second + 1, p[i].x, p[i].y, p[i].z&#125;);
                        v[i] = 0;
                    &#125; else &#123;
                        p[i].y %= m;
                        p[i].y ++;
                    &#125;
                &#125; else if(v[i] == 3) &#123;
                    ok = 1;
                    if(p[i].z == p[i].tz) &#123;
                        res.push_back(&#123;tt, i + 1, 0, t[2][p[i].x][p[i].y].second + 1, p[i].x, p[i].y, p[i].z&#125;);
                        v[i] = 0;
                    &#125; else &#123;
                        p[i].z %= h;
                        p[i].z ++;
                    &#125;
                &#125;
            &#125; else &#123;
                ok = 1;
            &#125;
        &#125;
        work();
        tt ++;
    &#125; while (ok);
    sort(res.begin(), res.end());
    for(auto i : res) &#123;
        // [time] Person person_id IN / OUT Elevator elevator_id at (x, y, z);
        if(i.io == 1) &#123;
            cout &lt;&lt; &quot;[&quot; &lt;&lt; i.tt &lt;&lt; &quot;s] Person &quot; &lt;&lt; i.p &lt;&lt; &quot; IN Elevator &quot; &lt;&lt; i.xl &lt;&lt; &quot; at (&quot; &lt;&lt; i.x &lt;&lt; &quot;, &quot; &lt;&lt; i.y &lt;&lt; &quot;, &quot; &lt;&lt; i.z &lt;&lt; &quot;)\n&quot;;
        &#125; else &#123;
            cout &lt;&lt; &quot;[&quot; &lt;&lt; i.tt &lt;&lt; &quot;s] Person &quot; &lt;&lt; i.p &lt;&lt; &quot; OUT Elevator &quot; &lt;&lt; i.xl &lt;&lt; &quot; at (&quot; &lt;&lt; i.x &lt;&lt; &quot;, &quot; &lt;&lt; i.y &lt;&lt; &quot;, &quot; &lt;&lt; i.z &lt;&lt; &quot;)\n&quot;;

        &#125;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>rust小记</title>
    <url>/2022/11/22/rust%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul>
<li>Linux<pre><code class="lang-shell">$ curl --proto &#39;=https&#39; --tlsv1.3 https://sh.rustup.rs -sSf | sh
</code></pre>
</li>
<li>windows<br>前往 <a href="https://www.rust-lang.org/install.html">https://www.rust-lang.org/install.html</a> 并按照说明安装 Rust</li>
</ul>
<h3 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h3><pre><code class="lang-shell">$ rustc --version
</code></pre>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><pre><code class="lang-shell">$ rustup update
</code></pre>
<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><pre><code class="lang-shell">$ rustup self uninstall
</code></pre>
<h3 id="本地文档"><a href="#本地文档" class="headerlink" title="本地文档"></a>本地文档</h3><pre><code class="lang-shell">rustup doc
</code></pre>
<h2 id="编译命令与Cargo"><a href="#编译命令与Cargo" class="headerlink" title="编译命令与Cargo"></a>编译命令与Cargo</h2><h3 id="rustc"><a href="#rustc" class="headerlink" title="rustc"></a>rustc</h3><p>和gcc差不多的用法</p>
<pre><code class="lang-shell">$ rust [-g] &#123;filename.rs&#125; [-o]
</code></pre>
<h3 id="Cargo"><a href="#Cargo" class="headerlink" title="Cargo"></a>Cargo</h3><ul>
<li>创建一个项目<pre><code class="lang-shell">$ cargo new &#123;dirname&#125;
</code></pre>
</li>
<li>构建<pre><code class="lang-shell">$ cargo build [--release]
</code></pre>
只确保通过编译<pre><code class="lang-shell">cargo check
</code></pre>
</li>
<li>运行<pre><code class="lang-shell">$ cargo run
</code></pre>
</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>rust中变量默认设置为不可变, 只能被覆盖, 需要加<code>mut</code>前缀设置为可变.<br><code>const</code>修饰常量, 常量可以是个算式</p>
<h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><div class="table-container">
<table>
<thead>
<tr>
<th>长度</th>
<th>有符号</th>
<th>无符号</th>
</tr>
</thead>
<tbody>
<tr>
<td>8-bit</td>
<td><code>i8</code></td>
<td><code>u8</code></td>
</tr>
<tr>
<td>16-bit</td>
<td><code>i16</code></td>
<td><code>u16</code></td>
</tr>
<tr>
<td>32-bit</td>
<td><code>i32</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>64-bit</td>
<td><code>i64</code></td>
<td><code>u64</code></td>
</tr>
<tr>
<td>128-bit</td>
<td><code>i128</code></td>
<td><code>u128</code></td>
</tr>
<tr>
<td>arch</td>
<td><code>isize</code></td>
<td><code>usize</code></td>
</tr>
</tbody>
</table>
</div>
<p>向$0$取整</p>
<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p><code>f32</code>, <code>f64</code></p>
<h3 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h3><p><code>bool</code>: <code>enum &#123; true, false &#125;</code></p>
<h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><p>UTF-8编码(2-bit)<br><code>char</code></p>
<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p><code>(i32, i32, i32)</code><br><code>.</code>访问</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><code>[i32; 10]</code> $10$个<code>i32</code>变量</p>
<h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><pre><code class="lang-rust">enum IpAddr&#123;
    V4: (u8, u8, u8, u8),
    V6: String,
&#125;
</code></pre>
<p>枚举类型中的值是可选项，用<code>::</code>来构造一个实例</p>
<pre><code class="lang-rust">let home = IpAddr::V4(192, 0, 0, 10);
</code></pre>
<ul>
<li>特殊的枚举类型<code>Option</code><br>这是一个定义在标准库内的类型<pre><code class="lang-rust">enum Option&lt;T&gt; &#123;
  None,
  Some(T),
&#125;
</code></pre>
</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>无返回值 (void) 的函数</p>
<pre><code class="lang-rust">fn function() &#123;
    // -- skip -- 
&#125;
</code></pre>
<p>带返回值的函数</p>
<pre><code class="lang-rust">fn function() -&gt; i32 &#123;
    // 两中返回值的方式都是可以的
    5
    //return 5;
&#125;
</code></pre>
<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>兼容 C 风格, 可以带<code>()</code></p>
<pre><code class="lang-rust">if x &lt; 5 &#123;
    x += 1;
&#125; else if x &lt; 10 &#123;
    x += 2;
&#125; else &#123;
    x += 3;
&#125;
</code></pre>
<h3 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h3><p>无限循环体</p>
<pre><code class="lang-rust">loop &#123;
    x += 1;
    if x &gt;= 100 &#123;
        break;
    &#125;
&#125;
</code></pre>
<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>兼容 C 风格, 可以带<code>()</code></p>
<pre><code class="lang-rust">while x &lt; 5 &#123;
    x += 1;
&#125;
</code></pre>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>遍历集合</p>
<pre><code class="lang-rust">let a = [0, 1, 2, 3, 4, 5];
for i in a &#123;
    print!(&quot;&#123;&#125;&quot;, i);
&#125;
</code></pre>
<p>逆序遍历索引</p>
<pre><code class="lang-rust">for i in (0..5).rev() &#123;
    // --skip--
&#125;
</code></pre>
<h3 id="match"><a href="#match" class="headerlink" title="match"></a>match</h3><p>类似 C 语言中的switch</p>
<pre><code class="lang-rust">enum IpAddr &#123;
    V4(String),
    V6(String),
&#125;
let home = IpAddr::V4(String::from(&quot;192, 0, 0, 1&quot;));
let ip = match home &#123;
    IpAddr::V4(s) =&gt; &#123;
        s
    &#125;,
    IpAddr::V6(s) =&gt; s
    // =&gt; 表示产生的效果

    other =&gt; String::from(&quot;0, 0, 0, 0&quot;),
    //match 是穷尽的 
&#125;;
</code></pre>
<h3 id="if-let"><a href="#if-let" class="headerlink" title="if let"></a>if let</h3><p>弱化版的match</p>
<pre><code class="lang-rust">if let IpAddr::V4(s) = home&#123;
    println!(&quot;&#123;&#125;&quot;, s);
&#125; else &#123;
    cnt += 1;
&#125;
println!(&quot;&#123;&#125;&quot;, cnt);
</code></pre>
<h2 id="结构体定义与实例"><a href="#结构体定义与实例" class="headerlink" title="结构体定义与实例"></a>结构体定义与实例</h2><p>贴个自己写的 BIT 基本就会用了</p>
<pre><code class="lang-rust">fn  main () &#123;
    let mut bit = BIT::new(200);
    for i in (1..bit.N) &#123;
        bit.add(i, 1);
    &#125;
    for i in (1..bit.N) &#123;
        println!(&quot;&#123;&#125;&quot;, bit.sum(i));
    &#125;
&#125;
struct BIT &#123;
    N: i32,
    s: [i32; 1000],
&#125;
impl BIT &#123;
  // 类似构造方法
    fn new(n: i32) -&gt; Self &#123;
        let bit  =  Self &#123;
            N: n,
            s: [0; 1000],
        &#125;;
        bit
    &#125;
    fn add(&amp;mut self, x: i32, y: i32) &#123;
        let mut i = x;
        while i &lt; self.N &#123;
            let inx: usize = i.try_into().unwrap(); // 索引要转化成 usize
            self.s[inx] += y;
            i += i &amp; - i;
        &#125;
    &#125;
    fn sum(&amp;self, x: i32) -&gt; i32 &#123;
        let mut res = 0;
        let mut i = x;
        while i &gt; 0 &#123;
            let inx: usize = i.try_into().unwrap();
            res += self.s[inx];
            i -= i &amp; - i;
        &#125;
        res
    &#125;
&#125;
</code></pre>
<h2 id="几种常见的封装集合"><a href="#几种常见的封装集合" class="headerlink" title="几种常见的封装集合"></a>几种常见的封装集合</h2><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>定义</p>
<pre><code class="lang-rust">let v1 = vec![1, 2, 3, 4];
let v2 = vec![0; 5];
let  mut v3: Vec&lt;i32&gt; = Vec::new();
</code></pre>
<p>几个常用的函数</p>
<ul>
<li>push</li>
<li>pop</li>
<li>append<pre><code class="lang-rust">// 将 v2 中的元素移动到 v1
v1.append(&amp;mut v2);
</code></pre>
</li>
<li>sort | sort_by<pre><code class="lang-rust">// 逆序排序
v1.sort_by(|a, b| b.cmp(a));
</code></pre>
</li>
<li>is_empty</li>
<li>len</li>
<li>resize</li>
</ul>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>定义</p>
<pre><code class="lang-rust">let s1 = String::from(&quot;hello, &quot;);
let s2 = &quot;world!&quot;.to_string();
let s3 = s1 + &amp;s2;
</code></pre>
<p>采用 UTF-8 编码，利用索引引用的时候两个连续的索引表示一位<code>char</code>。</p>
<h3 id="Hash-Map"><a href="#Hash-Map" class="headerlink" title="Hash Map"></a>Hash Map</h3><p>定义</p>
<pre><code class="lang-rust">let mut map = HashMap::new();
map.insert(&quot;red&quot;.to_string(), 1);
map.insert(&quot;blue&quot;.to_string(), 2);
map.insert(&quot;red&quot;.to_string(), 10);  // 覆盖
map.entry(&quot;red&quot;.to_string()).or_insert(10); // 不存在则插入一个值
let conut = map.entry(&quot;bule&quot;.to_string()).or_insert(0);
*conut += 1; // 更新map中的数据
let x = map.get(&amp;&quot;red&quot;.to_string()).copied().unwrap_or(0); // 得到一个不可变的值
</code></pre>
<p>这个语言学了一半先咕咕了，暂时要搞点正事。</p>
]]></content>
      <categories>
        <category>编程技能</category>
      </categories>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Splay</title>
    <url>/2022/11/28/Splay/</url>
    <content><![CDATA[<pre><code class="lang-cpp">int root, tot;
const int MAXN = 1e5 + 10;
struct ND &#123;
    int ch[2],  // 儿子
        f,      // 父亲
        siz,    // 子树大小
        val,    // 值
        cnt;    // 个数
&#125; nd[MAXN];
void update(int x) &#123;
    nd[x].siz = nd[nd[x].ch[0]].siz + nd[nd[x].ch[1]].siz + nd[x].cnt;
&#125;
void rotate(int x) &#123;
    int y = nd[x].f;
    int z = nd[y].f;
    int k = nd[y].ch[1] == x;
    nd[z].ch[nd[z].ch[1] == y] = x;
    nd[x].f = z;
    nd[y].ch[k] = nd[x].ch[k ^ 1];
    nd[nd[x].ch[k ^ 1]].f = y;
    nd[x].ch[k ^ 1] = y;
    nd[y].f = x;
    update(y), update(x);
&#125;
void splay(int x, int goal) &#123;
    while(nd[x].f != goal) &#123;
        int y = nd[x].f;
        int z = nd[y].f;
        if(z != goal) &#123;
            (nd[z].ch[1] == y) == (nd[y].ch[1] == x) ?
                rotate(y) : rotate(x);
        &#125;
        rotate(x);
    &#125;
    if(goal == 0) &#123;
        root = x;
    &#125;
&#125;
void find(int x) &#123;
    int u = root;
    if(!u) &#123;
        return;
    &#125;
    while(nd[u].ch[x &gt; nd[u].val] &amp;&amp; x != nd[u].val) &#123;
        u = nd[u].ch[x &gt; nd[u].val];
    &#125;
    splay(u, 0);
&#125;
void insert(int x) &#123;
    int u = root, f = 0;
    while(u &amp;&amp; nd[u].val != x) &#123;
        f = u;
        u = nd[u].ch[x &gt; nd[u].val];
    &#125;
    if(u) &#123;
        nd[u].cnt ++;
    &#125; else &#123;
        u = ++ tot;
        if(f) &#123;
            nd[f].ch[x &gt; nd[f].val] = u;
        &#125;
        nd[u].ch[0] = nd[u].ch[1] = 0;
        nd[u].f = f;
        nd[u].val = x;
        nd[u].cnt = 1;
        nd[u].siz = 1;
    &#125;
    splay(u, 0);
&#125;
int Next(int x) &#123;
    find(x);
    int u = root;
    if(nd[u].val &gt; x) return u;
    u = nd[u].ch[1];
    while(nd[u].ch[0]) u = nd[u].ch[0];
    return u;
&#125;
int Pre(int x) &#123;
    find(x);
    int u = root;
    if(nd[u].val &lt; x) return u;
    u = nd[u].ch[0];
    while(nd[u].ch[1]) u = nd[u].ch[1];
    return u;
&#125;
void del(int x) &#123;
    int pre = Pre(x), next = Next(x);
    splay(pre, 0), splay(next, pre);
    int del = nd[next].ch[0];
    if(nd[del].cnt &gt; 1) &#123;
        nd[del].cnt --;
        splay(del, 0);
    &#125; else &#123;
        nd[next].ch[0] = 0;
    &#125;
&#125;
int kth(int k) &#123;
    int u = root;
    if(nd[u].siz &lt; k) &#123;
        return 0;
    &#125;
    while(1) &#123;
        int y = nd[u].ch[0];
        if(k &gt; nd[y].siz + nd[u].cnt) &#123;
            k -= nd[y].siz + nd[u].cnt;
            u = nd[u].ch[1];
        &#125; else &#123;
            if(k &lt;= nd[y].siz) &#123;
                u = y;
            &#125; else &#123;
                return nd[u].val;
            &#125;
        &#125;
    &#125;
&#125;
#include &lt;bits/stdc++.h&gt;
using namespace std;
int main() &#123;
    ios::sync_with_stdio(0), cin.tie(0);
    int q;
    cin &gt;&gt; q;
    insert(1e9), insert(-1e9);
    while(q --) &#123;
        int op, x;
        cin &gt;&gt; op &gt;&gt; x;
        switch (op) &#123;
            case 1:
                insert(x);
                break;
            case 2:
                del(x);
                break;
            case 3:
                find(x);
                cout &lt;&lt; nd[nd[root].ch[0]].siz &lt;&lt; &#39;\n&#39;;
                break;
            case 4:
                cout &lt;&lt; kth(x + 1) &lt;&lt; &#39;\n&#39;;
                break;
            case 5:
                cout &lt;&lt; nd[Pre(x)].val &lt;&lt; &#39;\n&#39;;
                break;
            case 6:
                cout &lt;&lt; nd[Next(x)].val &lt;&lt; &#39;\n&#39;;
                break;
        &#125;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>Splay</tag>
      </tags>
  </entry>
  <entry>
    <title>dp题单</title>
    <url>/2022/11/15/dp%E9%A2%98%E5%8D%95/</url>
    <content><![CDATA[<p>这里多数问题只做简单解释，对部分题目给出链接细说。</p>
<p><a href="https://codeforces.com/problemset/problem/1513/C">Add One</a><br><a href="https://codeforces.com/problemset/problem/1733/D2">Zero-One</a><br><a href="https://atcoder.jp/contests/abc271/tasks/abc271_e">Subsequence Path</a><br><a href="https://codeforces.com/contest/1740/problem/E">Hanging Hearts</a><br><a href="https://atcoder.jp/contests/abl/tasks/abl_d">Flat Subsequence</a><br><a href="https://atcoder.jp/contests/abc184/tasks/abc184_d">increment of coins</a></p>
]]></content>
      <categories>
        <category>做题记录</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>三角剖分</title>
    <url>/2023/04/16/%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86/</url>
    <content><![CDATA[<h1 id="三角剖分"><a href="#三角剖分" class="headerlink" title="三角剖分"></a>三角剖分</h1><blockquote>
<ul>
<li>单纯形：<br>几何学上，单纯形或者$n$-单纯形是和三角形类似的$n$维几何体。精确的讲，单纯形是某个$n$维以上的欧几里得空间中的（$n+1$）个仿射无关（也就是没有$m-1$维平面包含$m+1$个点；这样的点集被称为处于一般位置）的点的集合的凸包。</li>
<li>仿射组合:<br>线性组合的子集, 要求在满足线性组合的条件下, 同时满足系数之和等于$1$. 例如: 一个元素的仿射组合为一个点, 两个元素的仿射组合为一条直线, 三个元素(仿射无关)的仿射组合为一个二维平面</li>
<li>仿射变换:<br>简言之就是线性变换 + 平移<blockquote>
<p>In Euclidean geometry, an affine transformation or affinity (from the Latin, affinis, “connected with”) is a geometric transformation that preserves lines and parallelism, but not necessarily Euclidean distances and angles.</p>
</blockquote>
</li>
</ul>
</blockquote>
<p><a href="https://en.wikipedia.org/wiki/Delaunay_triangulation">wikipedia</a></p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>分块简述</title>
    <url>/2022/10/11/%E5%88%86%E5%9D%97%E7%AE%80%E8%BF%B0/</url>
    <content><![CDATA[<h3 id="数组分块简述"><a href="#数组分块简述" class="headerlink" title="数组分块简述"></a>数组分块简述</h3><p>在某些情况下，我们可能需要暴力地处理数组的每一个数，数组分块提供了一种简单的优化来降低复杂度，使得原本的$O(n)$降为$O(\sqrt n)$，这可能不是最优解，但一定足够简单（事实上，在1e5范围内，$O(\log^2 n)$和$O(\sqrt n)$差距不大）。<br><strong>这类问题的“整体”性质更弱，有时不存在高效的信息合并化简方法，需要在“批量”和“零散”之间找到平衡点。</strong></p>
<ul>
<li>基础形式</li>
</ul>
<p>我们将一个数组分为形如下图的几段，每段大小为B，当然为了规范，如果$B \nmid n$，我们要在数组后面填充$inf$（在后面的一些处理中会用到这个）。对每次操作只需要对左右两个散块单独处理和对中间一些整块处理。<br><img src="https://s1.328888.xyz/2022/10/10/gfTOw.png" alt="图1"></p>
<p>理解了分块的概念以后，你就可以开始着手尝试用分块去解决一些线段树问题了（虽然此时分块对比线段树不占优）。</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h5 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a><a href="https://www.luogu.com.cn/problem/P3372">模板题</a></h5><p>题目大意：区间上所有元素加一个数$k$；求区间所有元素的和。<br>对于这个问题，简单地开三个数组$a,s,v$ 分别表示：数组值；分块中除去标记的数组值和；标记：分块中的每个元素 + k。</p>
<p>参考代码：<br>每个块的左右边界可以用结构体记录下来，也可以直接计算，这里采用的是直接计算的方式。</p>
<pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
typedef pair&lt;int, int&gt; PII;
const int INF = 1e9 + 7, MAXN = 1e5 + 10, mod = 998244353;
int BS;
ll a[MAXN], s[405], v[405];
void add(int l, int r, int k) &#123;
    int bl = l / BS, br = r / BS;
    if(bl == br) &#123;
        for(int i = l; i &lt;= r; i ++) &#123;
            a[i] += k, s[bl] += k;
        &#125;
    &#125; else &#123;
        for(int i = l; i &lt; (bl + 1) * BS; i ++) &#123;
            a[i] += k, s[bl] += k;
        &#125;
        for(int i = bl + 1; i &lt; br; i ++) &#123;
            v[i] += k, s[i] += 1ll * BS * k;
        &#125;
        for(int i = br * BS; i &lt;= r; i ++) &#123;
            a[i] += k, s[br] += k;
        &#125;
    &#125;
&#125;
ll query(int l, int r) &#123;
    ll res = 0;
    int bl = l / BS, br = r / BS;
    if(bl == br) &#123;
        for(int i = l; i &lt;= r; i ++) &#123;
            res += a[i] + v[bl];
        &#125;
    &#125; else &#123;
        for(int i = l; i &lt; (bl + 1) * BS; i ++) &#123;
            res += a[i] + v[bl];
        &#125;
        for(int i = bl + 1; i &lt; br; i ++) &#123;
            res += s[i];
        &#125;
        for(int i = br * BS; i &lt;= r; i ++) &#123;
            res += a[i] + v[br];
        &#125;
    &#125;
    return res;
&#125;
int main() &#123;
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    BS = sqrt(n) + 1;
    for(int i = 0; i &lt; n; i ++) &#123;
        cin &gt;&gt; a[i];
        s[i / BS]  += a[i];
    &#125;
    while(m -- ) &#123;
        int op, l, r, k;
        cin &gt;&gt; op  &gt;&gt; l &gt;&gt; r;
        l --, r --;
        if(op == 1) &#123;
            cin &gt;&gt; k;
            add(l, r, k);
        &#125; else &#123;
            cout &lt;&lt; query(l, r) &lt;&lt; &#39;\n&#39;;
        &#125;
    &#125;

&#125;
</code></pre>
<p>分块的大小可以人为确定，需要计算时间复杂度后再确定。此题中理论时间复杂度为$O(q (B + n / B))$， 另$B = \sqrt n$，得到最优时间复杂度$O(q \sqrt n)$。</p>
<h5 id="教主的魔法"><a href="#教主的魔法" class="headerlink" title="教主的魔法"></a><a href="https://www.luogu.com.cn/problem/P2801">教主的魔法</a></h5><p>题目大意：1、区间加；2、求区间大于$c$的元素个数。</p>
<p>首先来思考一下如何找出一个整块中大于$c$的元素个数<br>……<br>如果一个整块中的元素有序，那么是不是可以二分。</p>
<p>在上题中我们用$s$来维护区间和，现在我们用$s$来维护区间的有序数组。那么一个区间内大于$c$的元素个数就等于散块大于$c$的个数 + 每个整块中大于$c$的个数（这部分用lower_bound来处理）。单次询问时间复杂度为$O((n/B) log B + B)$。</p>
<p>在来思考一下区间加，由于需要额外维护一个有序数组，每次加操作可以对散块进行暴力排序，整块就在标记上加值，单词加的时间复杂度为$O(B log B + n / B)$。</p>
<blockquote>
<p>关于B的取值问题，首先应该考虑平衡两种操作的时间复杂度，其次应该考虑整块的时间复杂度和散块部分的时间复杂度，具体而言就是让两者相等求出B。比如此题中对散块重新排序可以优化成提取有序的两部分（有改动和无改动）再merge，此时加操作的时间复杂度就降为$O(B + n / B)$，发现这个复杂度是恒小于询问操作的复杂度的，此时就应该考虑适当增大B的大小，可以对$(n / B) log B + B$ 求导计算出极值，也可以用三分来求，事实上这个值约等于$\sqrt{n\log \sqrt n}$。</p>
</blockquote>
<p>参考代码（不加优化）：</p>
<pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
typedef pair&lt;int, int&gt; PII;
const int INF = 1e9 + 7, MAXN = 1100000, mod = 998244353;
int n, q, BS;
int a[MAXN], v[410], s[MAXN];
void add(int l, int r, int k) &#123;
    int bl = l / BS, br = r / BS;
    if(bl == br) &#123;
        for(int i = l; i &lt;= r; i ++) &#123;
            a[i] += k;
        &#125;
        for(int i = bl * BS; i &lt; (bl + 1) * BS; i ++) &#123;
            s[i] = a[i];
        &#125;
        sort(s + bl * BS, s + (bl + 1) * BS);
    &#125; else &#123;
        for(int i = l; i &lt; (bl + 1) * BS; i ++) &#123;
            a[i] += k;
        &#125;
        for(int i = bl * BS; i &lt; (bl + 1) * BS; i ++) &#123;
            s[i] = a[i];
        &#125;
        sort(s + bl * BS, s + (bl + 1) * BS);
        for(int i = bl + 1; i &lt; br; i ++) &#123;
            v[i] += k;
        &#125;
        for(int i = br * BS; i &lt;= r; i ++) &#123;
            a[i] += k;
        &#125;
        for(int i = br * BS; i &lt; (br + 1) * BS; i ++) &#123;
            s[i] = a[i];
        &#125;
        sort(s + br * BS, s + (br + 1) * BS);
    &#125;
&#125;
int query(int l, int r, int c) &#123;
    int bl = l / BS, br = r / BS;
    int C, res = 0;
    if(bl == br) &#123;
        C = c - v[bl];
        for(int i = l; i &lt;= r; i ++) &#123;
            if(a[i] &gt;= C) res ++;
        &#125;
    &#125; else &#123;
        C = c - v[bl];
        for(int i = l; i &lt; (bl + 1) * BS; i ++) &#123;
            if(a[i] &gt;= C) res ++;
        &#125;
        for(int i = bl + 1; i &lt; br; i ++) &#123;
            C = c - v[i];
            res += BS - (lower_bound(s + BS * i, s + BS * (i + 1), C) - (s + BS * i));
        &#125;
        C = c - v[br];
        for(int i = br * BS; i &lt;= r; i ++) &#123;
            if(a[i] &gt;= C) res ++;
        &#125;
    &#125;
    return res;
&#125;
int main() &#123;
    ios::sync_with_stdio(false);
    cin.tie(0);
    memset(a, 0x3f3f3f3f, sizeof a);
    cin &gt;&gt; n &gt;&gt; q;
    BS = sqrt(n) + 1;
    for(int i = 0; i &lt; n; i ++) &#123;
        cin &gt;&gt; a[i];
        s[i] = a[i];
    &#125;
    for(int i = 0; i * BS &lt;= n ; i ++) &#123;
        sort(s + i * BS, s + (i + 1) * BS);
    &#125;
    while(q --) &#123;
        char op;
        int l, r, x;
        cin &gt;&gt; op &gt;&gt; l &gt;&gt; r &gt;&gt; x;
        l --, r --;
        if(op == &#39;M&#39;) add(l, r, x);
        else cout &lt;&lt; query(l, r, x) &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;
</code></pre>
<p>稍稍写一下归并的代码（给一个结构体写的板子）</p>
<pre><code class="lang-cpp">int n, m, BS;
ll a[MAXN];
struct BLOCK &#123;
    int l, r;
    ll ex;
    vector&lt;ll&gt; B;
    vector&lt;int&gt; mp;
    BLOCK(int s) &#123;
        B.resize(s);
        ex = 0;
    &#125;
    BLOCK(int _l, int _r) &#123;
        ex = 0;
        l = _l, r = _r;
        int s = r - l + 1;
        B.resize(s);
        mp.resize(s);
        for(int i = l; i &lt;= r; i ++) &#123;
            mp[i - l] = i;
        &#125;
        sort(mp.begin(), mp.end(), [&amp;] (int x, int y)  &#123;
            return a[x] &lt; a[y];
        &#125;);
        for(int i = 0; i &lt; s; i ++) &#123;
            B[i] = a[mp[i]];
        &#125;
    &#125;
    void rebuild(int s, int t, int k) &#123;
        vector&lt;int&gt; _1, _2;
        for(int i = 0; i &lt; mp.size(); i ++) &#123;
            int x = mp[i];
            if(x &gt;= s &amp;&amp; x &lt;= t) &#123;
                _1.push_back(x);
            &#125; else &#123;
                _2.push_back(x);
            &#125;
        &#125;
        for(int i : _1) a[i] += k;
        int i = 0, j = 0, c = 0;
        while(i &lt; _1.size() &amp;&amp; j &lt; _2.size()) &#123;
            if(a[_1[i]] &lt; a[_2[j]]) mp[c ++] = _1[i ++];
            else mp[c ++] = _2[j ++];
        &#125;
        while(i &lt; _1.size()) mp[c ++] = _1[i ++];
        while(j &lt; _2.size()) mp[c ++] = _2[j ++];
        for(int i = 0; i &lt; mp.size(); i ++) B[i] = a[mp[i]];
    &#125;
&#125;;
vector&lt;BLOCK&gt; block;
void add(int l, int r, int k) &#123;
    int lb = l / BS, rb = r / BS;
    if(lb == rb) &#123;
        block[lb].rebuild(l, r, k);
    &#125; else &#123;
        block[lb].rebuild(l, block[lb].r, k);
        block[rb].rebuild(block[rb].l, r, k);
        for(int i = lb + 1; i &lt; rb; i ++) &#123;
            block[i].ex += k;
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="由乃打扑克"><a href="#由乃打扑克" class="headerlink" title="由乃打扑克"></a><a href="https://www.luogu.com.cn/problem/P5356">由乃打扑克</a></h5><blockquote>
<p>给你一个长为 $n$ 的序列 $a$，需要支持 $m$ 次操作，操作有两种：<br>1、查询区间 $[l,r]$ 的第 $k$ 小值。<br>2、区间 $[l,r]$ 加上 $k$。</p>
</blockquote>
<p>分块 + 整体二分</p>
<p>第$k$小的值$x$就相当于区间内存在$k-1$个数小于等于$x$，并且求这个值符合二分的规则，故可以整体二分确定$x$的大小，具体的check方法与上一例题一模一样。</p>
<p>几个优化：<br><strong>1.</strong> 二分前将左右两块散块合并，这样可以用$O(log\ B)$来代替对整个散块遍历的$O(B)$<br><strong>2.</strong> 二分前计算出二分的上下界，以减少二分次数。<br>复杂度分析：<br>add 时间复杂度$O(B + n / B）$<br>query 时间复杂度$O(B + (n / B)log\ B\ log\ w)$<br>（$log\ w$ 是二分是次数，大概为$20-30$）。</p>
<p>确定块长：理论上复杂度的计算应该是查询时间复杂度<br>对$B$求偏导得到的，但是按照理论来算的话，这题这么做是可以被卡掉的。于是需要调亿点点块长，下面这份代码块长取$912$可以拿到$82pts$（已经不想扣常数了）。</p>
<pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
typedef pair&lt;int, int&gt; PII;
const int INF = 1e9 + 7, MAXN = 1e5 + 9, mod = 998244353;
void read() &#123;&#125;
template&lt;typename T,typename... Ts&gt;
inline void read(T &amp;arg,Ts&amp;... args) &#123;
    T x = 0, f = 1;
    char c = getchar();
    while(!isdigit(c))&#123;if(c == &#39;-&#39;) f = -1; c = getchar();&#125;
    while(isdigit(c))&#123;x = (x &lt;&lt; 3) +(x &lt;&lt; 1) + (c - &#39;0&#39;);c = getchar();&#125;
    arg = x * f;
    read(args...);
&#125;
int n, m, BS;
ll a[MAXN];
int _1[MAXN], _2[MAXN], t1, t2;
struct BLOCK &#123;
    int l, r;
    ll ex;
    vector&lt;ll&gt; B;
    vector&lt;int&gt; mp;
    BLOCK(int s) &#123;
        B.resize(s);
        ex = 0;
    &#125;
    BLOCK(int _l, int _r) &#123;
        ex = 0;
        l = _l, r = _r;
        int s = r - l + 1;
        B.resize(s);
        mp.resize(s);
        for(int i = l; i &lt;= r; ++ i) &#123;
            mp[i - l] = i;
        &#125;
        sort(mp.begin(), mp.end(), [&amp;] (int x, int y)  &#123;
            return a[x] &lt; a[y];
        &#125;);
        for(int i = 0; i &lt; s; i ++) &#123;
            B[i] = a[mp[i]];
        &#125;
    &#125;
    void rebuild(int s, int t, int k) &#123;
        t1 = t2 = 0;
        for(int i = 0; i &lt; mp.size(); ++ i) &#123;
            int x = mp[i];
            if(x &gt;= s &amp;&amp; x &lt;= t) _1[t1 ++] = x;
            else _2[t2 ++] = x;
        &#125;
        for(int i = 0; i &lt; t1; ++ i) a[_1[i]] += k;
        int  i = 0, j = 0, c = 0;
        while(i &lt; t1 &amp;&amp; j &lt; t2) &#123;
            if(a[_1[i]] &lt; a[_2[j]]) mp[c ++] = _1[i ++];
            else mp[c ++] = _2[j ++];
        &#125;
        while(i &lt; t1) mp[c ++] = _1[i ++];
        while(j &lt; t2) mp[c ++] = _2[j ++];
        for(int i = 0; i &lt; mp.size(); i ++) B[i] = a[mp[i]];
    &#125;
&#125;;
vector&lt;BLOCK&gt; block;
inline void add(int l, int r, int k) &#123;
    int lb = l / BS, rb = r / BS;
    if(lb == rb) &#123;
        block[lb].rebuild(l, r, k);
    &#125; else &#123;
        block[lb].rebuild(l, block[lb].r, k);
        block[rb].rebuild(block[rb].l, r, k);
        for(int i = lb + 1; i &lt; rb; i ++) &#123;
            block[i].ex += k;
        &#125;
    &#125;
&#125;
inline ll query(int l, int r, int k) &#123;
    int lb = l / BS, rb = r / BS;
    if(lb == rb) &#123;
        int c = 0;
        for(int i : block[lb].mp) &#123;
            if(i &gt;= l &amp;&amp; i &lt;= r) c ++;
            if(c == k) return a[i] + block[lb].ex;
        &#125;
    &#125; else &#123;
        BLOCK _ex(block[lb].r - l + 1 + r - block[rb].l + 1);
        t1 = t2 = 0;
        for(int i : block[lb].mp) &#123;
            if(i &gt;= l) _1[t1 ++] = a[i] + block[lb].ex;
        &#125;
        for(int i : block[rb].mp) &#123;
            if(i &lt;= r) _2[t2 ++] = a[i] + block[rb].ex;
        &#125;
        int c = 0, i = 0, j = 0;
        while(i &lt; t1 &amp;&amp; j &lt; t2) &#123;
            if(_1[i] &lt; _2[j]) _ex.B[c ++] = _1[i ++];
            else _ex.B[c ++] = _2[j ++];
        &#125;
        while(i &lt; t1) _ex.B[c ++] = _1[i ++];
        while(j &lt; t2) _ex.B[c ++] = _2[j ++];
        ll L = 1e18, R = -1e18;
        L = min(L, _ex.B[0]);
        R = max(R, _ex.B.back());
        for(int i = lb + 1; i &lt; rb; ++ i) &#123;
            L = min(L, block[i].B[0] + block[i].ex);
            R = max(R, block[i].B.back() + block[i].ex);
        &#125;
        L --, R ++;
        while(R &gt; L + 1) &#123;
            ll M = L + R  &gt;&gt; 1;
            int cnt = 0;
            cnt += lower_bound(_ex.B.begin(), _ex.B.end(), M) - _ex.B.begin();
            for(int i = lb + 1; i &lt; rb; i ++) &#123;
                cnt += lower_bound(block[i].B.begin(), block[i].B.end(), M - block[i].ex) - block[i].B.begin();
            &#125;
            if(cnt &gt;= k) R = M;
            else L = M;
        &#125;
        return R - 1;
    &#125;
&#125;
int main() &#123;
    read(n, m);
    for(int i = 0; i &lt; n; ++ i) &#123;
        read(a[i]);
    &#125;
    BS = 912;
    for(int i = 0; 1ll * i * BS &lt; n; ++ i) &#123;
        int l = i * BS, r = min(n - 1, (i + 1) * BS - 1);
        block.push_back(BLOCK(l, r));
    &#125;
    while(m --) &#123;
        int op, l, r, k;
        read(op, l, r, k);
        l --, r --;
        if(op == 1) &#123;
            if(r - l + 1 &lt; k) &#123;
                cout &lt;&lt; &quot;-1\n&quot;;
            &#125; else &#123;
                printf(&quot;%lld\n&quot;, query(l, r, k));
            &#125;
        &#125; else &#123;
            add(l, r, k);
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="弹飞绵羊"><a href="#弹飞绵羊" class="headerlink" title="弹飞绵羊"></a><a href="https://www.luogu.com.cn/problem/P3203">弹飞绵羊</a></h5><blockquote>
<p>有$n$个点，每个点都有一个值$k$，第$i$个点会通过一次弹射到$i + k_i$上，直到点不存在。两种操作，一种询问第$i$个点一共会经历几次弹射，另一种修改$k_i$。</p>
</blockquote>
<p>如果不存在修改操作，那么只需要预处理出所有点的答案，每次查询只需要$O(1)$的复杂度就可以求出解。而修改的操作是$O(n)$的，因此需要一种方法来平衡两种操作。发现可以将所有点任意地分割成$x$段，每一小段中的每个点都存在一个$k’_i$从所在段中弹飞，并且落到另一段中的某个点，因此可以记录每个段中每个点从所在段弹飞的所需的次数以及落点，此时每次修改只需要修改所在块即可。故得出解：将$n$个点分成$\sqrt n$段，同时记录次数和位置，修改就重构块，查询就对该点在所有块中的次数求和。两种操作的时间复杂度均为$\sqrt n$。</p>
<pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
typedef pair&lt;int, int&gt; PII;
const int INF = 1e9 + 7, MAXN = 2e5 + 400, mod = 998244353;
int n, BS, m, B;
int a[MAXN], c[MAXN], to[MAXN];
void upd(int l, int r) &#123;
    for(int i = r; i &gt;= l; i --) &#123;
        if(i + a[i] &gt; r) &#123;
            c[i] = 1;
            to[i] = i + a[i];
        &#125; else &#123;
            c[i] = c[i + a[i]] + 1;
            to[i] = to[i + a[i]];
        &#125;
    &#125;
&#125;
int query(int x) &#123;
    int res = 0, pos = x;
    do &#123;
        res += c[pos];
        pos = to[pos];
    &#125; while(pos &lt; n);
    return res;
&#125;
int main() &#123;
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin &gt;&gt; n;
    BS = sqrt(n) + 1;
    for(int i = 0; i &lt; n; i ++) &#123;
        cin &gt;&gt; a[i];
    &#125;
    for(int i = 0; i &lt; n; i += BS) &#123;
        upd(i, min(n - 1, i + BS - 1));
    &#125;
    cin &gt;&gt; m;
    while (m --) &#123;
        int op, x, y;
        cin &gt;&gt; op &gt;&gt; x;
        if(op == 1) &#123;
            cout &lt;&lt; query(x) &lt;&lt; &#39;\n&#39;;
        &#125; else &#123;
            cin &gt;&gt; y;
            a[x] = y;
            int b = x / BS;
            upd(b * BS, min(n - 1, (b + 1) * BS - 1));
        &#125;
    &#125;
&#125;
</code></pre>
<p>  <br/><br>  <br/></p>
<ul>
<li>有时间再补<br><a href="https://loj.ac/p/6546">简单的数列题</a><br><a href="https://www.luogu.com.cn/problem/P4135">作诗</a><br><a href="https://www.luogu.com.cn/problem/P4168">[Violet]蒲公英</a><br><a href="https://www.luogu.com.cn/problem/P5574">任务分配问题</a></li>
</ul>
]]></content>
      <categories>
        <category>算法笔记</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title>基环树简述</title>
    <url>/2022/10/19/%E5%9F%BA%E7%8E%AF%E6%A0%91%E7%AE%80%E8%BF%B0/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>基环树指$n$个点$n$条边的连通图, 仅比树多一条边, 有大部分树的性质.<br><img src="https://static01.imgkr.com/temp/daf52d93387f444ab74d26d08050ee10.png" alt="图1"></p>
<h3 id="重要的事-找环"><a href="#重要的事-找环" class="headerlink" title="重要的事 找环"></a>重要的事 找环</h3><p>tarjan找环, 给一份容易实现的代码（不能找重边和自环）</p>
<pre><code class="lang-cpp">int n, m;
vector&lt;int&gt; G[MAXN];
namespace Circle &#123;
    vector&lt;int&gt; circle; // 环上的点
    int tag[MAXN]; // 标记: -1未访问; 1访问过; 2在环上
    void init() &#123;
        for(int i = 0; i &lt; n; i ++) &#123;
            tag[i] = -1;
        &#125;
    &#125;
    int dfs(int u, int f) &#123;
        if(tag[u] != -1) &#123;
            return u;
        &#125;
        tag[u] = 1;
        for(auto v : G[u]) if(v != f) &#123;
            int t = dfs(v, u);
            if(t &gt; -1) &#123;
                circle.push_back(u);
                tag[u] = 2;
                return t == u ? -1 : t;
            &#125;
        &#125;
        return -1;
    &#125;
&#125;
</code></pre>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a><a href="https://www.luogu.com.cn/problem/P5022">旅行</a></h4><ul>
<li>题目大意: 给定一棵普通树或者基环树, 求访问全部节点最小的字典序(每个节点只记录第一次访问).</li>
<li>对于一般树, 可以$1$节点开始跑; 对于基环树, 可以删一条边使其变成普通树, 时间复杂度$O(n^2)$</li>
<li>参考代码<pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
typedef pair&lt;int, int&gt; PII;
const int INF = 1e9 + 7, MAXN = 5e3 + 10, mod = 998244353;
int n, m;
vector&lt;int&gt; G[MAXN];
vector&lt;int&gt; res, ste;
namespace Circle &#123;
  vector&lt;int&gt; circle;
  int tag[MAXN];
  void init() &#123;
      for(int i = 0; i &lt; n; i ++) &#123;
          tag[i] = -1;
      &#125;
  &#125;
  int dfs(int u, int f) &#123;
      if(tag[u] != -1) &#123;
          return u;
      &#125;
      tag[u] = 1;
      for(auto v : G[u]) if(v != f) &#123;
          int t = dfs(v, u);
          if(t &gt; -1) &#123;
              circle.push_back(u);
              tag[u] = 2;
              return t == u ? -1 : t;
          &#125;
      &#125;
      return -1;
  &#125;
&#125;
bool cmp(vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;b) &#123;
  if(!a.size()) &#123;
      return 1;
  &#125; else &#123;
      for(int i = 0; i &lt; n; i ++) &#123;
          if(a[i] != b[i]) &#123;
              return a[i] &gt; b[i];
          &#125;
      &#125;
  &#125;
  return 0;
&#125;
int du = -1, dv = -1; // 删的边
void dfs(int u, int p) &#123;
  ste.push_back(u);
  for(int v : G[u]) if(v != p) &#123;
      if((du == u &amp;&amp; dv == v) || du == v &amp;&amp; dv == u) continue;
      dfs(v, u);
  &#125;
&#125;
int main() &#123;
  ios::sync_with_stdio(false);
  cin.tie(0);
  cin &gt;&gt; n &gt;&gt; m;
  for(int i = 0; i &lt; m; i ++) &#123;
      int u, v;
      cin &gt;&gt; u &gt;&gt; v;
      u --, v --;
      G[u].push_back(v), G[v].push_back(u);
  &#125;
  for(int i = 0; i &lt; n; i ++) &#123;
      sort(G[i].begin(), G[i].end());
  &#125;
  if(m == n - 1) &#123;
      dfs(0, 0);
      res = ste;
  &#125; else &#123;
      Circle::init();
      Circle::dfs(0, 0);
      for(int i = 0; i &lt; Circle::circle.size() - 1; i ++) &#123;
          du = Circle::circle[i], dv = Circle::circle[i + 1];
          ste.clear();
          dfs(0, 0);
          if(cmp(res, ste)) &#123;
              res = ste;
          &#125;
      &#125;
  &#125;
  for(int i : res) &#123;
      cout &lt;&lt; i + 1 &lt;&lt; &#39; &#39;;
  &#125;
&#125;
</code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>算法笔记</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>基环树</tag>
      </tags>
  </entry>
  <entry>
    <title>最小圆覆盖</title>
    <url>/2023/04/16/%E6%9C%80%E5%B0%8F%E5%9C%86%E8%A6%86%E7%9B%96/</url>
    <content><![CDATA[<h1 id="最小圆覆盖问题"><a href="#最小圆覆盖问题" class="headerlink" title="最小圆覆盖问题"></a>最小圆覆盖问题</h1><ul>
<li>问题描述：平面上$n$个点, 要求找到一个半径最小的圆, 能覆盖所有的点.</li>
</ul>
<p>算法思想: 随机增量法 (理论实践复杂度O(n) ? 但是最坏貌似还是$n^3$) 每次进入下一曾 for的概率都小于$\frac{3}{n}$. 因此每次随机化点可以尽可能地避免最坏情况的发生.</p>
<pre><code class="lang-cpp">int n;
Points ps(n);
random_shuffle(ps.begin(), ps.end()); // 随机化
Circle res(Point(0, 0), 0);
for(int i = 0; i &lt; n; i ++) &#123;
    // 圆是否包含点 i
    if(CCP(res, ps[i]) == out) &#123;
        res = Circle(ps[i], 0);
        for(int j = 0; j &lt; i; j ++) &#123;
            if(CCP(res, ps[j]) == out) &#123;
                // 两点确定一个圆
                res = Circle((ps[i] + ps[j]) / 2, dis(ps[i], ps[j]) / 2);
                for(int k = 0; k &lt; j; k ++) &#123;
                    if(CCP(res, ps[k]) == out) &#123;
                        // 三点确定一个圆
                        res = circumcircle(ps[i], ps[j], ps[k]);
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>莫队</title>
    <url>/2023/04/16/%E8%8E%AB%E9%98%9F/</url>
    <content><![CDATA[<h1 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h1><ul>
<li>算法原理:<br>对于序列上的查询问题, 如果[l, r] 的答案可以$O(1)$扩展到[l- 1, r], [l + 1, r], [l, r-1], [l, r + 1], 那么对于所有询问, 离线处理后可以在$n\sqrt{n}$的时间内找到所有问题的答案.</li>
<li><p>排序方法, 以及具体实现<br>对于区间$[l,r]$, 以$l$所在块的编号为第一关键字升序, $r$为第二关键字排序升序.<br>优化: 若$l$所在块编号为奇数, 则按$r$为第二关键字升序, 反正则按降序.<br>具体实现见例题, 主要是编写$O(1)$扩展部分的代码</p>
</li>
<li><p>例题:<br><a href="https://codeforces.com/contest/86/problem/D">Powerful array</a><br>题目大意:<br>对于给定数列$a$, 每次询问一个区间$[l, r]$, 区间的值是每个数字出现的次数的平方乘这个数本身的和,即$\sum k_s^2 \times s$</p>
</li>
</ul>
<pre><code class="lang-cpp">signed main () &#123;
    ios::sync_with_stdio(0), cin.tie(0);
    int n, t;
    cin &gt;&gt; n &gt;&gt; t;
    vector&lt;int&gt; a(n);
    int bs = sqrt(n);
    for(int i = 0; i &lt; n; i ++) &#123;
        cin &gt;&gt; a[i];
    &#125;
    struct query &#123;
        int l, r, id;
    &#125;;
    vector&lt;query&gt; q(t);
    for(int i = 0; i &lt; t; i ++) &#123;
        auto &amp;[l, r, id] = q[i];
        cin &gt;&gt; l &gt;&gt; r;
        l --, r --;
        id = i;
    &#125;
    sort(q.begin(), q.end(), [&amp;] (query a, query b) &#123;
        if(a.l / bs != b.l / bs) return a.l &lt; b.l;
        return (a.l / bs) &amp; 1 ? a.r &lt; b.r : a.r &gt; b.r;
    &#125;);
    i64 res = 0;
    vector&lt;i64&gt; ans(t);
    vector&lt;int&gt; cnt(MAXN);
    for(int i = 0, ll = 0, rr = -1; i &lt; t; i ++) &#123;
        auto &amp;[l, r, id] = q[i];
        while (rr &lt; r) &#123;
            int x = a[++ rr];
            i64 fi = 1ll * cnt[x] * cnt[x] * x;
            cnt[x] ++;
            i64 se = 1ll * cnt[x] * cnt[x] * x;
            res = res - fi + se;
        &#125;
        while(rr &gt; r) &#123;
            int x = a[rr --];
            i64 fi = 1ll * cnt[x] * cnt[x] * x;
            cnt[x] --;
            i64 se = 1ll * cnt[x] * cnt[x] * x;
            res = res - fi + se;
        &#125;
        while(ll &lt; l) &#123;
            int x = a[ll ++];
            i64 fi = 1ll * cnt[x] * cnt[x] * x;
            cnt[x] --;
            i64 se = 1ll * cnt[x] * cnt[x] * x;
            res = res - fi + se;
        &#125;
        while(ll &gt; l) &#123;
            int x = a[-- ll];
            i64 fi = 1ll * cnt[x] * cnt[x] * x;
            cnt[x] ++;
            i64 se = 1ll * cnt[x] * cnt[x] * x;
            res = res - fi + se;
        &#125;
        ans[id] = res;
    &#125;
    for(i64 i : ans) &#123;
        cout &lt;&lt; i &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>闵可夫斯基和</title>
    <url>/2023/04/16/%E9%97%B5%E5%8F%AF%E5%A4%AB%E6%96%AF%E5%9F%BA%E5%92%8C/</url>
    <content><![CDATA[<h1 id="闵可夫斯基和"><a href="#闵可夫斯基和" class="headerlink" title="闵可夫斯基和"></a>闵可夫斯基和</h1><p>定义: 对于欧式空间上的两个点集 $A, B$, 存在点集 $C$ 满足 ${a + b \in C|a \in A,b\in B }$ （$a, b$均为向量的形式）, 则称 $C$ 为$A, B$的闵可夫斯基和, 即</p>
<script type="math/tex; mode=display">
    C = A + B</script><p>差 (different):<br>$C = A - B = {a - b | a \in A, b \in B} = A + (-B)$<br>表示对$\forall a \in A, \forall b \in B, \exist c \in C (c = a - b)$<br>或者可以这样理解$\forall c \in C, \exists b \in B, \exist a \in A (a =  c + b)$</p>
<p>==warning==: 这里的加号和减号不是一对可以互逆的运算, $(A - B) + B \neq A$</p>
<p><a href="https://en.wikipedia.org/wiki/Minkowski_addition">wikipedia</a></p>
<ul>
<li>例题(第一道过的洛谷黑题):</li>
</ul>
<p><a href="https://www.luogu.com.cn/problem/P4557">战争</a></p>
<p>题目大意: 有两个部落$A,B$, 两个部落分别有$n, m$个人, 如两个部落所围成的凸包没有重合的点, 则不会发生战争. 现在$B$部落的全部人打算向$(x, y)$向量迁移, 有$q$次询问, 问是否会发生战争.</p>
<p>思路是找到一个点集$C$, 满足$\forall c \in C, \exists b \in B 满足 c + b \in A$, 这和前面差的定义是相同的, 故此题转化为了求$C = A - B$, 然后每次询问二分判断点是否在$C$内.</p>
<p>参考代码 (包含了<strong>闵可夫斯基和</strong>以及<strong>判断一个点是否在凸包内</strong>):</p>
<pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
using Real = long long;
struct Point &#123;
    Real x, y;
    Point() &#123;&#125;
    Point(Real x, Real y) : x(x), y(y) &#123;&#125;
    friend istream&amp; operator &gt;&gt; (istream &amp;is, Point&amp; v) &#123;
        return is &gt;&gt; v.x &gt;&gt; v.y;
    &#125;
    Point&amp; operator+= (const Point&amp; p) &#123;
        x += p.x, y += p.y;
        return *this;
    &#125;
    Point&amp; operator-= (const Point&amp; p) &#123;
        x -= p.x, y -= p.y;
        return *this;
    &#125;
    Point operator+ (const Point&amp; p) const &#123;
        return Point(*this) += p;
    &#125;
    Point operator- (const Point&amp; p) const &#123;
        return Point(*this) -= p;
    &#125;
    Point operator- () &#123;
        return Point(-x, -y);
    &#125;
    friend Real crs(const Point&amp; a, const Point&amp; b) &#123;
        return a.x * b.y - a.y * b.x;
    &#125;
    bool operator&lt; (const Point&amp; p) const &#123;
        if(x != p.x) return x &lt; p.x;
        return y &lt; p.y;
    &#125;
&#125;;
using Points = vector&lt;Point&gt;;
enum position &#123; CCW = 1, CW = -1, ON = 0 &#125;;
int ccw(const Point&amp; a, Point b, Point c) &#123;
    b -= a, c -= a;
    if(crs(b, c) &gt; 0) return CCW;
    if(crs(b, c) &lt; 0) return CW;
    return ON;
&#125;
int ccw(Point a, Point b) &#123;
    return ccw(Point(0, 0), a, b);
&#125;
Points Convexhell(Points&amp; ps) &#123;
    int n = ps.size(), k = 0;
    Points res(2 * n);
    sort(ps.begin(), ps.end());
    for(int i = 0; i &lt; n; res[k ++] = ps[i ++]) &#123;
        while(k &gt;= 2 &amp;&amp; ccw(res[k - 2], res[k - 1], ps[i]) != CCW) &#123;
            k --;
        &#125;
    &#125;
    for(int i = n - 2, t = k + 1; i &gt;= 0; res[k ++] = ps[i --]) &#123;
        while(k &gt;= t &amp;&amp; ccw(res[k - 2], res[k - 1], ps[i]) != CCW) &#123;
            k --;
        &#125;
    &#125;
    res.resize(k - 1);
    return res;
&#125;
Points Minkowski(Points&amp; A, Points&amp; B) &#123;
    int n = A.size(), m = B.size();
    Points res (n + m + 1);
    res[0] = A[0] + B[0];
    int k = 1, i = 0, j = 0;
    int cA = 0, cB = 0;
    while(cA &lt; n &amp;&amp; cB &lt; m) &#123;
        int nxi = (i + 1) % n, nxj = (j + 1) % m;
        Point x = A[nxi] - A[i];
        Point y = B[nxj] - B[j];
        if(ccw(x, y) == CCW) &#123;
            res[k ++] = res[k - 1] + x;
            i = nxi, cA ++;
        &#125; else if(ccw(x, y) == CW) &#123;
            res[k ++] = res[k - 1] + y;
            j = nxj, cB ++;
        &#125; else &#123;
            res[k ++] = res[k - 1] + x + y;
            j = nxj, i = nxi;
            cA ++, cB ++;
        &#125;
    &#125;
    while(cA &lt; n) &#123;
        int nxi = (i + 1) % n;
        res[k ++] = res[k - 1] + A[nxi] - A[i];
        cA ++, i = nxi;
    &#125;
    while(cB &lt; m) &#123;
        int nxj = (j + 1) % m;
        res[k ++] = res[k - 1] + B[nxj] - B[j];
        cB ++, j = nxj;
    &#125;
    res.resize(k - 1);
    return res;
&#125;
bool check_in(Point&amp; p, Points&amp; ps) &#123;
    int n = ps.size();
    int O = 0, l = 1, r = n - 1;
    if(ccw(ps[O], ps[r], p) == CCW || ccw(ps[O], ps[l], p) == CW) &#123;
        return false;
    &#125;
    while(l + 1 &lt; r) &#123;
        int m = l + r &gt;&gt; 1;
        if(ccw(ps[O], ps[m], p) == CCW) &#123;
            l = m;
        &#125; else &#123;
            r = m;
        &#125;
    &#125;
    if(ccw(ps[l], ps[r], p) == CW) &#123;
        return false;
    &#125; else &#123;
        return true;
    &#125;
&#125;
void solve() &#123;
    int n, m, q;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;
    Points A(n), B(m);
    for(int i = 0; i &lt; n; i ++) &#123;
        cin &gt;&gt; A[i];
    &#125;
    for(int i = 0; i &lt; m; i ++) &#123;
        cin &gt;&gt; B[i];
        B[i] = -B[i];
    &#125;
    A = Convexhell(A); n = A.size();
    B = Convexhell(B); m = B.size();
    Points C = Minkowski(A, B);
    while(q --) &#123;
        Point query;
        cin &gt;&gt; query;
        if(check_in(query, C)) &#123;
            cout &lt;&lt; &quot;1\n&quot;;
        &#125; else &#123;
            cout &lt;&lt; &quot;0\n&quot;;
        &#125;
    &#125;
&#125;
int main() &#123;
    ios::sync_with_stdio(false), cin.tie(0);
    int _ = 1;
    while(_ --) solve();
&#125;
</code></pre>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>模运算规范及表达式求模板值</title>
    <url>/2022/10/30/%E6%A8%A1%E8%BF%90%E7%AE%97%E8%A7%84%E8%8C%83%E5%8F%8A%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E6%A8%A1%E6%9D%BF%E5%80%BC/</url>
    <content><![CDATA[<h3 id="模运算规范，避免不必要的数值越界"><a href="#模运算规范，避免不必要的数值越界" class="headerlink" title="模运算规范，避免不必要的数值越界"></a>模运算规范，避免不必要的数值越界</h3><pre><code class="lang-cpp">const int mod = 998244353;
inline int add(int a,int b)&#123; return a + b &lt; mod ? a + b : a + b - mod;&#125;
inline int sub(int a,int b)&#123; return a &lt; b ? mod + a - b : a - b;&#125;
inline int mul(int a,int b)&#123; return 1ll * a * b % mod; &#125;
</code></pre>
<h3 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h3><pre><code class="lang-cpp">namespace CAL &#123;
    int expression(char*&amp;s);  // 计算一个不带括号的表达式值
    int token(char*&amp;s) &#123;      // 取出一个值加入到栈中
        if(*s == &#39;(&#39;) &#123;
            s ++;
            int ret = expression(s);
            s ++;
            return ret;
        &#125;
        int ret = 0;
        while(&#39;0&#39; &lt;= *s &amp;&amp; *s &lt;= &#39;9&#39;)&#123;
            ret = ret * 10 + *s++ - &#39;0&#39;;
        &#125;
        return ret % mod;
    &#125;
    int rank(char op) &#123;
        switch(op) &#123;
            case &#39;-&#39;: return 1;
            case &#39;+&#39;: return 1;
            case &#39;*&#39;: return 0;
        &#125;
        return 2;
    &#125;
    int expression(char*&amp;s)&#123;
        stack&lt;int&gt; svar;
        stack&lt;char&gt; sop;
        svar.push(token(s));
        while(true)&#123;
            char op = *s;
            if(!op || op == &#39;)&#39;) op = &#39;$&#39;;
            else s++;
            while(!sop.empty() &amp;&amp; rank(sop.top()) &lt;= rank(op))&#123;
                int b = svar.top();
                svar.pop();
                int a = svar.top();
                svar.pop();
                switch(sop.top())&#123;
                    case &#39;+&#39;:&#123;
                        svar.push(add(a, b));
                        break;
                    &#125;
                    case &#39;-&#39;:&#123;
                        svar.push(sub(a, b));
                        break;
                    &#125;
                    case &#39;*&#39;: &#123;
                        svar.push(mul(a, b));
                        break;
                    &#125;
                &#125;
                sop.pop();
            &#125;
            if(op == &#39;$&#39;) break;
            svar.push(token(s));
            sop.push(op);
        &#125;
        return svar.top();
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>模拟表达式求值</tag>
      </tags>
  </entry>
  <entry>
    <title>高质量题解（持续更新中）</title>
    <url>/2022/12/22/%E9%AB%98%E8%B4%A8%E9%87%8F%E9%A2%98%E8%A7%A3%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/gym/103446/problem/H">TLife is a Gam</a><br>题目大意: 给定一张$n$个点$m$条边的无向连通图, 每个点拥有点权$a$, 每条边拥有边权$w$. 有$q$次询问, 每次询问给定初始点$x$和初始能力值$k$, 从$x$点出发, 可以通过小于等于当前能力值的边到达另一个点, 每次到达一个未经过的点便获得这个点的点权, 求最大的能力值.</p>
<p>对于任意一张图, 所走过的边一定属于该图的最小生成树, 这一点用Kruskal很容易证明, 对于一条$u, v$的边, 如果点$u$和点$v$已经连通, 这条边的边权一定大于等于$u, v$路径上的所有边的边权.<br>那么这题的一个朴素想法便是构建该图的最小生成树, 对于每次询问, 从$x$出发, 跑一个优先队列维护的bfs即可, 然而时限显然不够.<br>对于这类多次询问的问题的优化, 有两种基本的思路: 其一是对数据进行预处理, 从而降低每次查询的复杂度; 其二是离线查询.<br>对于最小生成树的预处理有 Kruskal 重构树. 我们让重构树的每个点维护其子树的能力增加量和所需的能力值, 从点$x$开始, 一直向上搜索它的父节点, 直到无法向上搜素或者搜索到根节点为止. 但是重构树的高度最坏为$n$, 这意味着每次查询的最坏复杂度为$O(n)$, 还是差点的时限!<br>我们需要再多一点的预处理, 树上的预处理似乎可以用树上倍增来处理. 尝试写一个长度为$2$的转移: $bz[i][1] = max(bz[i][0], bz[fa[i][0]][0])$, 似乎不难理解并且可行, 那么至此此题的最终复杂度$O(qlog\ n)$.</p>
<p>参考代码</p>
<pre><code class="lang-cpp">const int MAXN = 1e5 + 10;
struct EDGE &#123;
    int u, v, w;
    bool operator&lt; (const EDGE &amp;a) const &#123;
        return w &lt; a.w;
    &#125;;
&#125;;
struct DSU &#123;
    int N;
    vector&lt;int&gt; p;
    DSU(int n) &#123;
        N = n;
        p.resize(n);
        for(int i = 0; i &lt; n; i ++) &#123;
            p[i] = i;
        &#125;
    &#125;
    int root(int x) &#123;
        return p[x] == x ? x : p[x] = root(p[x]);
    &#125;
    bool merge(int x, int y) &#123;
        int X = root(x), Y = root(y);
        if(X == Y) return 1;
        p[X] = Y;
        return 0;
    &#125;
&#125;;
struct NODE &#123;
    int f = -1, w = 0;
    ll add = 0;
&#125;;
NODE node[MAXN &lt;&lt; 1];
vector&lt;EDGE&gt; e;
ll bz[MAXN &lt;&lt; 1][17];
int fa[MAXN &lt;&lt; 1][17];
int n, m, q;
int main () &#123;
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;
    e.resize(m);
    vector&lt;int&gt; a(n);
    for(int i = 0; i &lt; n; i ++) &#123;
        cin &gt;&gt; a[i];
        node[i].add = a[i];
    &#125;
    for(auto &amp;[u, v, w] : e) &#123;
        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
        u --, v --;
    &#125;
    sort(e.begin(), e.end());
    DSU dsu(2 * n + 10);
    for(auto &amp;[u, v, w] : e) &#123;
        int U = dsu.root(u), V = dsu.root(v);
        if(U != V) &#123;
            dsu.merge(U, n), dsu.merge(V, n);
            node[U].f = node[V].f = n;
            node[n].add = node[U].add + node[V].add;
            node[n].w = w;
            n ++;
        &#125;
    &#125;
    for(int i = 0; i &lt; n; i ++) &#123;
        fa[i][0] = node[i].f;
        bz[i][0] = node[node[i].f].w - node[i].add;
    &#125;
    for(int i = 1; i &lt; 17; i ++) &#123;
        for(int j = 0; j &lt; n; j ++) &#123;
            if(fa[j][i - 1] == - 1) &#123;
                fa[j][i] = -1;
                continue;
            &#125;
            fa[j][i] = fa[fa[j][i - 1]][i - 1];
            bz[j][i] = max(bz[j][i - 1], bz[fa[j][i - 1]][i - 1]);
        &#125;
    &#125;
    while(q --) &#123;
        int x, k;
        cin &gt;&gt; x &gt;&gt; k;
        x --;
        for(int i = 16; i &gt;= 0; i --) &#123;
            if(fa[x][i] != -1) &#123;
                if(bz[x][i] &lt;= k) &#123;
                    x = fa[x][i];
                &#125;
            &#125;
        &#125;
        ll res = k + node[x].add;
        cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;
</code></pre>
<p><a href="https://codeforces.com/gym/103446/problem/M">Harmony in Harmony</a><br>题目大意: $n$个人将大小为$1$的地均分两次, 第一次每人分得$1/n$, 第二次同样分为大小相同的$n$份, $n$人自行分配, 要求使得第一次和第二次区域的交集最小的人的值最大, 第二次均分地时有一种分法, 使得这个值最小, 求出这个值.</p>
<p>首先可以猜测此题的答案存在一个上界$\frac{1}{n^2}$. 可以将此过程看作一个完全二分图匹配, 我们可以列出一个$n\times n$的表格, 其中每行的值之和为$\frac{1}{n}$, 每列的值之和为$1$, 所求的值为表格中坐标为 $(i, i)$ 的最小值. 我们假定 $(i, i)$ 为我们要找的最小值, 那么为了让这个值最小, 可以让 $\sum_{k = 1}^{i - 1}(k, i)$ 最大, 又因为要让每人分得的土地最大, 可以让前$i-1$个人分得的土地一样大都为$\frac{1}{in}$, 那么$i$分得的土地大小应为$\frac{\frac{1}{n}-\frac{i-1}{in}}{n-i+1}$, 验证此值小于等于$\frac{1}{n^2}$, 故枚举 $i$ 求出答案.</p>
<p>参考代码:</p>
<pre><code class="lang-cpp">int main () &#123;
    int n;
    scanf(&quot;%d&quot;, &amp;n);
    double res = 1;
    for(int i = 0; i &lt;= n; i ++) &#123;
        res = min(res, 1.0 / (n * (n + 1 - i) * i));
    &#125;
    printf(&quot;%.9f&quot;, res);
&#125;
</code></pre>
<p><a href="https://codeforces.com/gym/103470/problem/D">Paimon Sorting</a><br>题目大意: 给出一种$n^2$的排序方式, 询问数组长度为$k$时, 在排序的过程中交换了几次$k\in [1, n]$.<br>假设我们已经知道长度为$x$的结果, 那么怎么样可以推出$x + 1$的结果就是此题的关键. 设已经出现的最大值为$mx$, 考虑下面几种情况: $a[x] &lt; mx$; $a[x] = mx$; $a[x] &gt; mx$.<br>首先考虑第一种情况, 注意到该排序每轮是将最大值交换到$i$位置, 因此对于这种情况只需要考虑最后一轮, 从$1$到$x$位置,每次遇到大于$a[x]$的数便交换, 实际交换的次数为大于$a[x]$的数的集合的大小.<br>其次考虑第三种情况, 首先$a[x]$会走所有前一个最大值所有经过的路径, 此过程的价值为$0$, 其次$a[x]$ 会被移动到$1$位置, 再被移动到$x$位置, 此段的价值为 $2$.<br>最后考虑第二中情况, 显然它本身的价值应该为$0$, 但是它会对下一个 mx 移动到末位置产生阻碍(增加那一段的价值).这段增量为此时的位置到下一个mx位置的长度.</p>
<p>参考代码:</p>
<pre><code class="lang-cpp">struct BIT &#123;
    int N;
    vector&lt;int&gt; c;
    BIT(int n) &#123;
        N = n;
        c.resize(N);
    &#125;;
    void add(int x) &#123;
        for(int i = x; i &lt; N; i += (i &amp; (-i))) &#123;
            c[i] += 1;
        &#125;
    &#125;
    ll sum(int x) &#123;
        ll res = 0;
        for(int i = x; i; i -= (i &amp; (-i))) &#123;
            res += c[i];
        &#125;
        return res;
    &#125;
    ll sum(int l, int r) &#123;
        return sum(r) - sum(l - 1);
    &#125;
&#125;;
void solve() &#123;
    int n;
    cin &gt;&gt; n;
    vector&lt;int&gt; a(n);
    for(int i = 0; i &lt; n; i ++) &#123;
        cin &gt;&gt; a[i];
    &#125;
    ll res = 0;
    BIT bit(n + 10);
    vector&lt;int&gt; tol(n + 1);
    int len = -2;
    int mx = 0;
    for(int i = 0; i &lt; n; i ++) &#123;
        if(mx &lt; a[i]) &#123;
            res += 2 + len;
            mx = a[i];
            len = 0;
        &#125; else if(mx == a[i]) &#123;
            len ++;
        &#125; else &#123;
            if(len) len ++;
        &#125;
        res += bit.sum(a[i] + 1, n + 5);
        if(!tol[a[i]]) &#123;
            tol[a[i]] = 1;
            bit.add(a[i]);
        &#125;
        cout &lt;&lt; res;
        if(i == n - 1) &#123;
            cout &lt;&lt; &#39;\n&#39;;
        &#125; else &#123;
            cout &lt;&lt; &#39; &#39;;
        &#125;
    &#125;
&#125;
</code></pre>
<p><a href="https://codeforces.com/gym/104114/problem/E">Exercise</a><br>题目大意: 给定$2n$个数, 原本(1, 2), (3, 4) … 是一组, 现在要重新分组, 但不能维持原来的组, 问重新分组后每组两个值差的绝对值和的最小值.<br>显然从小到大排序之后, 相邻的两个数分为一个组会使得绝对值和最小, 但不一定符合条件, 于是我们希望能通过某种方法使得所有不合法的组都合法.<br>发现需要被最优的重组方式一定是与相邻的组进行重组, 且增量为$2(p<em>{i + 1,l} - p</em>{i,r})$.<br>可以考虑一种这样的DP, $dp_{i,j}$, 其中$i$表示考虑到第$i$组, $j$表示该组是否需要被重组.<br>可以写出转移方程: </p>
<script type="math/tex; mode=display">
\begin{matrix}
    dp_{i, 1} = dp_{i-1, 0}\\
    dp_{i, 0} = min(dp_{i-1,0},\ dp_{i,0},\ dp_{i,1} + 2(p_{i + 1,l} - p_{i,r}))
\end{matrix}</script><p>参考代码:</p>
<pre><code class="lang-cpp">const ll INF = (1ll &lt;&lt; 60);
struct PAIR &#123;
    ll l, r;
    bool bad = 0;
&#125;;
void solve() &#123;
    int n;
    cin &gt;&gt; n;
    vector&lt;PII&gt; a(2 * n);
    for(int i = 0; i &lt; 2 * n; i ++) &#123;
        cin &gt;&gt; a[i].first;
        a[i].second = i + 1;
    &#125;
    sort(a.begin(), a.end());
    ll res = 0;
    vector&lt;PAIR&gt; p(n);
    for(int i = 0; i &lt; n; i ++) &#123;
        p[i].l = a[2 * i].first;
        p[i].r = a[2 * i + 1].first;
        res += p[i].r - p[i].l;
        int mx = max(a[2 * i].second, a[2 * i + 1].second);
        int mi = min(a[2 * i].second, a[2 * i + 1].second);
        if(mx - 1 == mi &amp;&amp; (mx % 2 == 0)) &#123;
            p[i].bad = 1;
        &#125;
    &#125;
    vector&lt;array&lt;ll, 2&gt;&gt; dp(n);
    dp[0][0] = dp[0][1] = INF;
    dp[0][p[0].bad] = 0;
    for(int i = 1; i &lt; n; i ++) &#123;
        dp[i][0] = dp[i][1] = INF;
        dp[i][p[i].bad] = dp[i - 1][0];
        dp[i][0] = min(dp[i][0], min(dp[i - 1][0], dp[i - 1][1]) + 2 * (p[i].l - p[i - 1].r));
    &#125;
    res += dp[n - 1][0];
    cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre>
<p><a href="https://codeforces.com/gym/104114/problem/F">Fortune over Sportsmanship</a><br>题目大意: $n$人参见一个网球比赛, 一个$n\times n$的方格表示$(i, j)$进行比赛时收获的人气, 比赛总共进行$n - 1$轮, 胜方获得败方的人气(二者取max), 且败方淘汰出局.现在希望求出比赛可能收获的人气最大值, 并找出赛程.</p>
<p>考虑一种贪心的过程, 每次使当前状态下人气最大的两名选手进行比赛, 因为会继承败方的人气, 所以无论哪名选手淘汰都没关系. 可以用优先队列来模拟比赛.</p>
<p>参考代码:</p>
<pre><code class="lang-cpp">struct Z &#123;
    int val;
    int x, y;
    bool operator&lt; (const Z &amp;a) const &#123;
        if(val != a.val) &#123;
            return val &lt; a.val;
        &#125; else &#123;
            return x &lt; y;
        &#125;
    &#125;
&#125;;
void solve() &#123;
    int n;
    cin &gt;&gt; n;
    ll res = 0;
    vector&lt;vector&lt;int&gt;&gt; p(n, vector&lt;int&gt; (n));
    vector&lt;bool&gt; over(n);
    vector&lt;PII&gt; op;
    for(int i = 0; i &lt; n; i ++) &#123;
        for(int j = 0; j &lt; n; j ++) &#123;
            cin &gt;&gt; p[i][j];
        &#125;
    &#125;
    priority_queue&lt;Z&gt; q;
    for(int i = 0; i &lt; n; i ++) &#123;
        for(int j = i + 1; j &lt; n; j ++) &#123;
            q.push(&#123;p[i][j], i, j&#125;);
        &#125;
    &#125;
    while(q.size()) &#123;
        int v = q.top().val;
        int x = q.top().x;
        int y = q.top().y;
        q.pop();
        if(!over[x] &amp;&amp; !over[y]) &#123;
            op.push_back(&#123;x, y&#125;);
            res += v;
            over[y] = 1;
            for(int i = 0; i &lt; n; i ++) &#123;
                if(over[i] || i == x) continue;
                p[i][x] = p[x][i] = max(p[x][i], p[y][i]);
                q.push(&#123;p[x][i], min(x, i), max(x ,i)&#125;);
            &#125;
        &#125;
    &#125;
    cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    for(auto &amp;[x, y] : op) &#123;
        cout &lt;&lt; x + 1 &lt;&lt; &#39; &#39; &lt;&lt; y + 1 &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;
</code></pre>
<p><a href="https://codeforces.com/contest/1772/problem/G">Gaining Rating</a><br>题目大意: Monocarp 想提高自己在某下棋网站上的rating, 希望从$x$上升到$y$. 现在有$n$个对手, 每个对手有相应的rating $a_i$, rating 变化的规则为, 获胜加$1$, 失败减$1$但是对手的rating不变, Monocarp 只能下赢rating不大于自己的对手, 同时他可以自己挑选对手, 但是任意两个对手进行对弈的次数差不能大于$1$. 问需要多少轮才能达到目标或者说是不可能的.</p>
<p>显然, 首先需要对所有对手的rating进行一次排序. 我们考虑模拟一轮获得增量, 首先能够赢过$t$个人, 再败给$n-t$个人, 一轮总共获得的分数为$2t-n$, 如果距离所需达成的最终目标小于等于$t$时, 我们便可以不进入下一轮, 反之, 如果这一轮获得的分数小于等于$0$时, 无论如何都无法达到目标. 我们考虑如何求出$t$, 显然直接对$a$进行upper_bound是错误的, 因为我们的分数是在变化的. 可以考虑维护一个$b_i = a_i - i$表示想一路赢到$i$所需的最小rating. 但是这样的$b$不是单调的, 我们将不单调的$b_i$向下合并, 并增设权值, 这样我们得到了一个可以$log$求出$t$的数组.</p>
<pre><code class="lang-cpp">sort(a.begin(), a.end());
vector&lt;ll&gt; b = a;
for(int i = 0; i &lt; n; i ++) &#123;
    b[i] -= i;
&#125;
vector&lt;int&gt; s(1, 1);
vector&lt;ll&gt; v(1, b[0]);
for(int i = 1; i &lt; n; i ++) &#123;
    if(b[i] &lt;= v.back()) &#123;
        s.back() ++;
    &#125; else &#123;
        v.push_back(b[i]);
        s.push_back(1);
    &#125;
&#125;
v.push_back(1e18);
for(int i = 1; i &lt; s.size(); i ++) &#123;
    s[i] += s[i - 1];
&#125;
</code></pre>
<p>上述代码中$v$表示所说的单调数组, $s$表示增量, 接下来我们还不能一下子求出最后的答案, 我们将$v$中数值的大小视为分段的分界线, 已经知道了当前一轮所获得的增量, 我们要判断增量发生变化的值与$y-s_i$哪一个先到, 依次模拟每个分段便能求出最后的答案.</p>
<p>参考代码:</p>
<pre><code class="lang-cpp">void solve() &#123;
    int n;
    ll x, y;
    cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;
    vector&lt;ll&gt; a(n);
    for(int i = 0; i &lt; n; i ++) &#123;
        cin &gt;&gt; a[i];
    &#125;
    sort(a.begin(), a.end());
    vector&lt;ll&gt; b = a;
    for(int i = 0; i &lt; n; i ++) &#123;
        b[i] -= i;
    &#125;
    vector&lt;int&gt; s(1, 1);
    vector&lt;ll&gt; v(1, b[0]);
    for(int i = 1; i &lt; n; i ++) &#123;
        if(b[i] &lt;= v.back()) &#123;
            s.back() ++;
        &#125; else &#123;
            v.push_back(b[i]);
            s.push_back(1);
        &#125;
    &#125;
    v.push_back(1e18);
    for(int i = 1; i &lt; s.size(); i ++) &#123;
        s[i] += s[i - 1];
    &#125;
    for(int i = 1; i &lt; s.size(); i ++) &#123;
        s[i] += s[i - 1];
    &#125;
    ll res = 0;
    while(1) &#123;
        int i = upper_bound(v.begin(), v.end(), x) - v.begin();
        if(!i) &#123;
            cout &lt;&lt; -1 &lt;&lt; &#39;\n&#39;;
            return ;
        &#125;
        if(x + s[i - 1] &gt;= y) &#123;
            cout &lt;&lt; res + y - x &lt;&lt; &#39;\n&#39;;
            return ;
        &#125; else &#123;
            int add = 2 * s[i - 1] - n;
            if(add &lt;= 0) &#123;
                cout &lt;&lt; -1 &lt;&lt; &#39;\n&#39;;
                return;
            &#125; else &#123;
                ll ter = min(y - s[i - 1], v[i]);
                ll cnt = (teg - x + add - 1) / add;
                res += cnt * n;
                x += cnt * add;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p><a href="https://codeforces.com/contest/1754/problem/F">https://codeforces.com/contest/1754/problem/F</a><br><a href="https://codeforces.com/contest/822/problem/C">https://codeforces.com/contest/822/problem/C</a><br><a href="https://codeforces.com/contest/229/problem/D">https://codeforces.com/contest/229/problem/D</a><br><a href="https://codeforces.com/contest/1288/problem/D">https://codeforces.com/contest/1288/problem/D</a><br><a href="https://codeforces.com/gym/104114/problem/G">https://codeforces.com/gym/104114/problem/G</a><br><a href="https://codeforces.com/gym/103446/problem/J">https://codeforces.com/gym/103446/problem/J</a><br><a href="https://codeforces.com/gym/103470/problem/I">https://codeforces.com/gym/103470/problem/I</a></p>
<p><a href="https://codeforces.com/gym/103447/problem/G">https://codeforces.com/gym/103447/problem/G</a><br><a href="https://codeforces.com/gym/104023/problem/J">https://codeforces.com/gym/104023/problem/J</a><br><a href="https://codeforces.com/gym/104023/problem/D">https://codeforces.com/gym/104023/problem/D</a></p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
</search>
