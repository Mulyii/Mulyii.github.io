
<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8" />
        <title>Muly&#39;s blog</title>
        <meta name="author" content="晓染" />
        <meta name="description" content="A blog records study of Algorithm, Math and Physics" />
        <meta name="keywords" content="blog" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
        <link rel="icon" href="/images/favicon.png" />
        <script src="https://cdn.staticfile.org/vue/3.2.47/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.3.0/css/all.min.css" />
<link rel="stylesheet" href="/css/fonts.min.css" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.7.0/highlight.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.7.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://cdn.staticfile.org/KaTeX/0.16.4/katex.min.js"></script>
<script src="https://cdn.staticfile.org/KaTeX/0.16.4/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.16.4/katex.min.css" />
<script src="/js/lib/math.js"></script>






<script src="/js/lib/home.js"></script>

<link rel="stylesheet" href="/css/main.css" />

    <meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <div id="layout">
            <transition name="fade">
                <div id="loading" v-show="loading">
                    <div id="loading-circle">
                        <h2>LOADING</h2>
                        <p>加载过慢请开启缓存 浏览器默认开启</p>
                        <img src="/images/loading.gif" />
                    </div>
                </div>
            </transition>
            <nav id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <div id="desktop-menu">
        <a class="title" href="/">
            <span>MULY&#39;S BLOG</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-首页 fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-关于 fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-归档 fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-分类 fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-标签 fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </div>
    <div id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;MULY&#39;S BLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-首页 fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-关于 fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-归档 fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-分类 fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-标签 fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </div>
</nav>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

            <transition name="into">
                <div id="main" v-show="!loading">
                    <div id="home-head">
    <div id="home-background" ref="homeBackground" data-images="/images/background.jpg"></div>
    <div id="home-info" @click="homeClick">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>Muly&#39;s blog</h1>
                <h3></h3>
                <h5>A blog records study of Algorithm, Math and Physics</h5>
            </div>
        </span>
    </div>
</div>
<div id="home-posts-wrap" class="home-posts-wrap-no-card" ref="homePostsWrap">
    <div id="home-posts">
        

<div class="post">
    <a href="/2023/04/16/%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86/">
        <h2 class="post-title">三角剖分</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                算法竞赛
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/4/16
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="三角剖分"><a href="#三角剖分" class="headerlink" title="三角剖分"></a>三角剖分</h1><blockquote>
<ul>
<li>单纯形：<br>几何学上，单纯形或者$n$-单纯形是和三角形类似的$n$维几何体。精确的讲，单纯形是某个$n$维以上的欧几里得空间中的（$n+1$）个仿射无关（也就是没有$m-1$维平面包含$m+1$个点；这样的点集被称为处于一般位置）的点的集合的凸包。</li>
<li>仿射组合:<br>线性组合的子集, 要求在满足线性组合的条件下, 同时满足系数之和等于$1$. 例如: 一个元素的仿射组合为一个点, 两个元素的仿射组合为一条直线, 三个元素(仿射无关)的仿射组合为一个二维平面</li>
<li>仿射变换:<br>简言之就是线性变换 + 平移<blockquote>
<p>In Euclidean geometry, an affine transformation or affinity (from the Latin, affinis, “connected with”) is a geometric transformation that preserves lines and parallelism, but not necessarily Euclidean distances and angles.</p>
</blockquote>
</li>
</ul>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Delaunay_triangulation">wikipedia</a></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/" style="color: #03a9f4">计算几何</a>
        </span>
        
    </div>
    <a href="/2023/04/16/%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2023/04/16/%E8%8E%AB%E9%98%9F/">
        <h2 class="post-title">莫队</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                算法竞赛
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/4/16
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h1><ul>
<li>算法原理:<br>对于序列上的查询问题, 如果[l, r] 的答案可以$O(1)$扩展到[l- 1, r], [l + 1, r], [l, r-1], [l, r + 1], 那么对于所有询问, 离线处理后可以在$n\sqrt{n}$的时间内找到所有问题的答案.</li>
<li><p>排序方法, 以及具体实现<br>对于区间$[l,r]$, 以$l$所在块的编号为第一关键字升序, $r$为第二关键字排序升序.<br>优化: 若$l$所在块编号为奇数, 则按$r$为第二关键字升序, 反正则按降序.<br>具体实现见例题, 主要是编写$O(1)$扩展部分的代码</p>
</li>
<li><p>例题:<br><a target="_blank" rel="noopener" href="https://codeforces.com/contest/86/problem/D">Powerful array</a><br>题目大意:<br>对于给定数列$a$, 每次询问一个区间$[l, r]$, 区间的值是每个数字出现的次数的平方乘这个数本身的和,即$\sum k_s^2 \times s$</p>
</li>
</ul>
<pre><code class="lang-cpp">signed main () &#123;
    ios::sync_with_stdio(0), cin.tie(0);
    int n, t;
    cin &gt;&gt; n &gt;&gt; t;
    vector&lt;int&gt; a(n);
    int bs = sqrt(n);
    for(int i = 0; i &lt; n; i ++) &#123;
        cin &gt;&gt; a[i];
    &#125;
    struct query &#123;
        int l, r, id;
    &#125;;
    vector&lt;query&gt; q(t);
    for(int i = 0; i &lt; t; i ++) &#123;
        auto &amp;[l, r, id] = q[i];
        cin &gt;&gt; l &gt;&gt; r;
        l --, r --;
        id = i;
    &#125;
    sort(q.begin(), q.end(), [&amp;] (query a, query b) &#123;
        if(a.l / bs != b.l / bs) return a.l &lt; b.l;
        return (a.l / bs) &amp; 1 ? a.r &lt; b.r : a.r &gt; b.r;
    &#125;);
    i64 res = 0;
    vector&lt;i64&gt; ans(t);
    vector&lt;int&gt; cnt(MAXN);
    for(int i = 0, ll = 0, rr = -1; i &lt; t; i ++) &#123;
        auto &amp;[l, r, id] = q[i];
        while (rr &lt; r) &#123;
            int x = a[++ rr];
            i64 fi = 1ll * cnt[x] * cnt[x] * x;
            cnt[x] ++;
            i64 se = 1ll * cnt[x] * cnt[x] * x;
            res = res - fi + se;
        &#125;
        while(rr &gt; r) &#123;
            int x = a[rr --];
            i64 fi = 1ll * cnt[x] * cnt[x] * x;
            cnt[x] --;
            i64 se = 1ll * cnt[x] * cnt[x] * x;
            res = res - fi + se;
        &#125;
        while(ll &lt; l) &#123;
            int x = a[ll ++];
            i64 fi = 1ll * cnt[x] * cnt[x] * x;
            cnt[x] --;
            i64 se = 1ll * cnt[x] * cnt[x] * x;
            res = res - fi + se;
        &#125;
        while(ll &gt; l) &#123;
            int x = a[-- ll];
            i64 fi = 1ll * cnt[x] * cnt[x] * x;
            cnt[x] ++;
            i64 se = 1ll * cnt[x] * cnt[x] * x;
            res = res - fi + se;
        &#125;
        ans[id] = res;
    &#125;
    for(i64 i : ans) &#123;
        cout &lt;&lt; i &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="color: #00bcd4">数据结构</a>
        </span>
        
    </div>
    <a href="/2023/04/16/%E8%8E%AB%E9%98%9F/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2023/04/16/%E6%9C%80%E5%B0%8F%E5%9C%86%E8%A6%86%E7%9B%96/">
        <h2 class="post-title">最小圆覆盖</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                算法竞赛
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/4/16
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="最小圆覆盖问题"><a href="#最小圆覆盖问题" class="headerlink" title="最小圆覆盖问题"></a>最小圆覆盖问题</h1><ul>
<li>问题描述：平面上$n$个点, 要求找到一个半径最小的圆, 能覆盖所有的点.</li>
</ul>
<p>算法思想: 随机增量法 (理论实践复杂度O(n) ? 但是最坏貌似还是$n^3$) 每次进入下一曾 for的概率都小于$\frac{3}{n}$. 因此每次随机化点可以尽可能地避免最坏情况的发生.</p>
<pre><code class="lang-cpp">int n;
Points ps(n);
random_shuffle(ps.begin(), ps.end()); // 随机化
Circle res(Point(0, 0), 0);
for(int i = 0; i &lt; n; i ++) &#123;
    // 圆是否包含点 i
    if(CCP(res, ps[i]) == out) &#123;
        res = Circle(ps[i], 0);
        for(int j = 0; j &lt; i; j ++) &#123;
            if(CCP(res, ps[j]) == out) &#123;
                // 两点确定一个圆
                res = Circle((ps[i] + ps[j]) / 2, dis(ps[i], ps[j]) / 2);
                for(int k = 0; k &lt; j; k ++) &#123;
                    if(CCP(res, ps[k]) == out) &#123;
                        // 三点确定一个圆
                        res = circumcircle(ps[i], ps[j], ps[k]);
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/" style="color: #ff7d73">计算几何</a>
        </span>
        
    </div>
    <a href="/2023/04/16/%E6%9C%80%E5%B0%8F%E5%9C%86%E8%A6%86%E7%9B%96/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2023/04/16/%E9%97%B5%E5%8F%AF%E5%A4%AB%E6%96%AF%E5%9F%BA%E5%92%8C/">
        <h2 class="post-title">闵可夫斯基和</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                算法竞赛
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/4/16
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="闵可夫斯基和"><a href="#闵可夫斯基和" class="headerlink" title="闵可夫斯基和"></a>闵可夫斯基和</h1><p>定义: 对于欧式空间上的两个点集 $A, B$, 存在点集 $C$ 满足 ${a + b \in C|a \in A,b\in B }$ （$a, b$均为向量的形式）, 则称 $C$ 为$A, B$的闵可夫斯基和, 即</p>
<script type="math/tex; mode=display">
    C = A + B</script><p>差 (different):<br>$C = A - B = {a - b | a \in A, b \in B} = A + (-B)$<br>表示对$\forall a \in A, \forall b \in B, \exist c \in C (c = a - b)$<br>或者可以这样理解$\forall c \in C, \exists b \in B, \exist a \in A (a =  c + b)$</p>
<p>==warning==: 这里的加号和减号不是一对可以互逆的运算, $(A - B) + B \neq A$</p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Minkowski_addition">wikipedia</a></p>
<ul>
<li>例题(第一道过的洛谷黑题):</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4557">战争</a></p>
<p>题目大意: 有两个部落$A,B$, 两个部落分别有$n, m$个人, 如两个部落所围成的凸包没有重合的点, 则不会发生战争. 现在$B$部落的全部人打算向$(x, y)$向量迁移, 有$q$次询问, 问是否会发生战争.</p>
<p>思路是找到一个点集$C$, 满足$\forall c \in C, \exists b \in B 满足 c + b \in A$, 这和前面差的定义是相同的, 故此题转化为了求$C = A - B$, 然后每次询问二分判断点是否在$C$内.</p>
<p>参考代码 (包含了<strong>闵可夫斯基和</strong>以及<strong>判断一个点是否在凸包内</strong>):</p>
<pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
using Real = long long;
struct Point &#123;
    Real x, y;
    Point() &#123;&#125;
    Point(Real x, Real y) : x(x), y(y) &#123;&#125;
    friend istream&amp; operator &gt;&gt; (istream &amp;is, Point&amp; v) &#123;
        return is &gt;&gt; v.x &gt;&gt; v.y;
    &#125;
    Point&amp; operator+= (const Point&amp; p) &#123;
        x += p.x, y += p.y;
        return *this;
    &#125;
    Point&amp; operator-= (const Point&amp; p) &#123;
        x -= p.x, y -= p.y;
        return *this;
    &#125;
    Point operator+ (const Point&amp; p) const &#123;
        return Point(*this) += p;
    &#125;
    Point operator- (const Point&amp; p) const &#123;
        return Point(*this) -= p;
    &#125;
    Point operator- () &#123;
        return Point(-x, -y);
    &#125;
    friend Real crs(const Point&amp; a, const Point&amp; b) &#123;
        return a.x * b.y - a.y * b.x;
    &#125;
    bool operator&lt; (const Point&amp; p) const &#123;
        if(x != p.x) return x &lt; p.x;
        return y &lt; p.y;
    &#125;
&#125;;
using Points = vector&lt;Point&gt;;
enum position &#123; CCW = 1, CW = -1, ON = 0 &#125;;
int ccw(const Point&amp; a, Point b, Point c) &#123;
    b -= a, c -= a;
    if(crs(b, c) &gt; 0) return CCW;
    if(crs(b, c) &lt; 0) return CW;
    return ON;
&#125;
int ccw(Point a, Point b) &#123;
    return ccw(Point(0, 0), a, b);
&#125;
Points Convexhell(Points&amp; ps) &#123;
    int n = ps.size(), k = 0;
    Points res(2 * n);
    sort(ps.begin(), ps.end());
    for(int i = 0; i &lt; n; res[k ++] = ps[i ++]) &#123;
        while(k &gt;= 2 &amp;&amp; ccw(res[k - 2], res[k - 1], ps[i]) != CCW) &#123;
            k --;
        &#125;
    &#125;
    for(int i = n - 2, t = k + 1; i &gt;= 0; res[k ++] = ps[i --]) &#123;
        while(k &gt;= t &amp;&amp; ccw(res[k - 2], res[k - 1], ps[i]) != CCW) &#123;
            k --;
        &#125;
    &#125;
    res.resize(k - 1);
    return res;
&#125;
Points Minkowski(Points&amp; A, Points&amp; B) &#123;
    int n = A.size(), m = B.size();
    Points res (n + m + 1);
    res[0] = A[0] + B[0];
    int k = 1, i = 0, j = 0;
    int cA = 0, cB = 0;
    while(cA &lt; n &amp;&amp; cB &lt; m) &#123;
        int nxi = (i + 1) % n, nxj = (j + 1) % m;
        Point x = A[nxi] - A[i];
        Point y = B[nxj] - B[j];
        if(ccw(x, y) == CCW) &#123;
            res[k ++] = res[k - 1] + x;
            i = nxi, cA ++;
        &#125; else if(ccw(x, y) == CW) &#123;
            res[k ++] = res[k - 1] + y;
            j = nxj, cB ++;
        &#125; else &#123;
            res[k ++] = res[k - 1] + x + y;
            j = nxj, i = nxi;
            cA ++, cB ++;
        &#125;
    &#125;
    while(cA &lt; n) &#123;
        int nxi = (i + 1) % n;
        res[k ++] = res[k - 1] + A[nxi] - A[i];
        cA ++, i = nxi;
    &#125;
    while(cB &lt; m) &#123;
        int nxj = (j + 1) % m;
        res[k ++] = res[k - 1] + B[nxj] - B[j];
        cB ++, j = nxj;
    &#125;
    res.resize(k - 1);
    return res;
&#125;
bool check_in(Point&amp; p, Points&amp; ps) &#123;
    int n = ps.size();
    int O = 0, l = 1, r = n - 1;
    if(ccw(ps[O], ps[r], p) == CCW || ccw(ps[O], ps[l], p) == CW) &#123;
        return false;
    &#125;
    while(l + 1 &lt; r) &#123;
        int m = l + r &gt;&gt; 1;
        if(ccw(ps[O], ps[m], p) == CCW) &#123;
            l = m;
        &#125; else &#123;
            r = m;
        &#125;
    &#125;
    if(ccw(ps[l], ps[r], p) == CW) &#123;
        return false;
    &#125; else &#123;
        return true;
    &#125;
&#125;
void solve() &#123;
    int n, m, q;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;
    Points A(n), B(m);
    for(int i = 0; i &lt; n; i ++) &#123;
        cin &gt;&gt; A[i];
    &#125;
    for(int i = 0; i &lt; m; i ++) &#123;
        cin &gt;&gt; B[i];
        B[i] = -B[i];
    &#125;
    A = Convexhell(A); n = A.size();
    B = Convexhell(B); m = B.size();
    Points C = Minkowski(A, B);
    while(q --) &#123;
        Point query;
        cin &gt;&gt; query;
        if(check_in(query, C)) &#123;
            cout &lt;&lt; &quot;1\n&quot;;
        &#125; else &#123;
            cout &lt;&lt; &quot;0\n&quot;;
        &#125;
    &#125;
&#125;
int main() &#123;
    ios::sync_with_stdio(false), cin.tie(0);
    int _ = 1;
    while(_ --) solve();
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/" style="color: #00bcd4">计算几何</a>
        </span>
        
    </div>
    <a href="/2023/04/16/%E9%97%B5%E5%8F%AF%E5%A4%AB%E6%96%AF%E5%9F%BA%E5%92%8C/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/12/22/%E9%AB%98%E8%B4%A8%E9%87%8F%E9%A2%98%E8%A7%A3%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/">
        <h2 class="post-title">高质量题解（持续更新中）</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                算法竞赛
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/12/22
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p><a target="_blank" rel="noopener" href="https://codeforces.com/gym/103446/problem/H">TLife is a Gam</a><br>题目大意: 给定一张$n$个点$m$条边的无向连通图, 每个点拥有点权$a$, 每条边拥有边权$w$. 有$q$次询问, 每次询问给定初始点$x$和初始能力值$k$, 从$x$点出发, 可以通过小于等于当前能力值的边到达另一个点, 每次到达一个未经过的点便获得这个点的点权, 求最大的能力值.</p>
<p>对于任意一张图, 所走过的边一定属于该图的最小生成树, 这一点用Kruskal很容易证明, 对于一条$u, v$的边, 如果点$u$和点$v$已经连通, 这条边的边权一定大于等于$u, v$路径上的所有边的边权.<br>那么这题的一个朴素想法便是构建该图的最小生成树, 对于每次询问, 从$x$出发, 跑一个优先队列维护的bfs即可, 然而时限显然不够.<br>对于这类多次询问的问题的优化, 有两种基本的思路: 其一是对数据进行预处理, 从而降低每次查询的复杂度; 其二是离线查询.<br>对于最小生成树的预处理有 Kruskal 重构树. 我们让重构树的每个点维护其子树的能力增加量和所需的能力值, 从点$x$开始, 一直向上搜索它的父节点, 直到无法向上搜素或者搜索到根节点为止. 但是重构树的高度最坏为$n$, 这意味着每次查询的最坏复杂度为$O(n)$, 还是差点的时限!<br>我们需要再多一点的预处理, 树上的预处理似乎可以用树上倍增来处理. 尝试写一个长度为$2$的转移: $bz[i][1] = max(bz[i][0], bz[fa[i][0]][0])$, 似乎不难理解并且可行, 那么至此此题的最终复杂度$O(qlog\ n)$.</p>
<p>参考代码</p>
<pre><code class="lang-cpp">const int MAXN = 1e5 + 10;
struct EDGE &#123;
    int u, v, w;
    bool operator&lt; (const EDGE &amp;a) const &#123;
        return w &lt; a.w;
    &#125;;
&#125;;
struct DSU &#123;
    int N;
    vector&lt;int&gt; p;
    DSU(int n) &#123;
        N = n;
        p.resize(n);
        for(int i = 0; i &lt; n; i ++) &#123;
            p[i] = i;
        &#125;
    &#125;
    int root(int x) &#123;
        return p[x] == x ? x : p[x] = root(p[x]);
    &#125;
    bool merge(int x, int y) &#123;
        int X = root(x), Y = root(y);
        if(X == Y) return 1;
        p[X] = Y;
        return 0;
    &#125;
&#125;;
struct NODE &#123;
    int f = -1, w = 0;
    ll add = 0;
&#125;;
NODE node[MAXN &lt;&lt; 1];
vector&lt;EDGE&gt; e;
ll bz[MAXN &lt;&lt; 1][17];
int fa[MAXN &lt;&lt; 1][17];
int n, m, q;
int main () &#123;
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;
    e.resize(m);
    vector&lt;int&gt; a(n);
    for(int i = 0; i &lt; n; i ++) &#123;
        cin &gt;&gt; a[i];
        node[i].add = a[i];
    &#125;
    for(auto &amp;[u, v, w] : e) &#123;
        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
        u --, v --;
    &#125;
    sort(e.begin(), e.end());
    DSU dsu(2 * n + 10);
    for(auto &amp;[u, v, w] : e) &#123;
        int U = dsu.root(u), V = dsu.root(v);
        if(U != V) &#123;
            dsu.merge(U, n), dsu.merge(V, n);
            node[U].f = node[V].f = n;
            node[n].add = node[U].add + node[V].add;
            node[n].w = w;
            n ++;
        &#125;
    &#125;
    for(int i = 0; i &lt; n; i ++) &#123;
        fa[i][0] = node[i].f;
        bz[i][0] = node[node[i].f].w - node[i].add;
    &#125;
    for(int i = 1; i &lt; 17; i ++) &#123;
        for(int j = 0; j &lt; n; j ++) &#123;
            if(fa[j][i - 1] == - 1) &#123;
                fa[j][i] = -1;
                continue;
            &#125;
            fa[j][i] = fa[fa[j][i - 1]][i - 1];
            bz[j][i] = max(bz[j][i - 1], bz[fa[j][i - 1]][i - 1]);
        &#125;
    &#125;
    while(q --) &#123;
        int x, k;
        cin &gt;&gt; x &gt;&gt; k;
        x --;
        for(int i = 16; i &gt;= 0; i --) &#123;
            if(fa[x][i] != -1) &#123;
                if(bz[x][i] &lt;= k) &#123;
                    x = fa[x][i];
                &#125;
            &#125;
        &#125;
        ll res = k + node[x].add;
        cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/gym/103446/problem/M">Harmony in Harmony</a><br>题目大意: $n$个人将大小为$1$的地均分两次, 第一次每人分得$1/n$, 第二次同样分为大小相同的$n$份, $n$人自行分配, 要求使得第一次和第二次区域的交集最小的人的值最大, 第二次均分地时有一种分法, 使得这个值最小, 求出这个值.</p>
<p>首先可以猜测此题的答案存在一个上界$\frac{1}{n^2}$. 可以将此过程看作一个完全二分图匹配, 我们可以列出一个$n\times n$的表格, 其中每行的值之和为$\frac{1}{n}$, 每列的值之和为$1$, 所求的值为表格中坐标为 $(i, i)$ 的最小值. 我们假定 $(i, i)$ 为我们要找的最小值, 那么为了让这个值最小, 可以让 $\sum_{k = 1}^{i - 1}(k, i)$ 最大, 又因为要让每人分得的土地最大, 可以让前$i-1$个人分得的土地一样大都为$\frac{1}{in}$, 那么$i$分得的土地大小应为$\frac{\frac{1}{n}-\frac{i-1}{in}}{n-i+1}$, 验证此值小于等于$\frac{1}{n^2}$, 故枚举 $i$ 求出答案.</p>
<p>参考代码:</p>
<pre><code class="lang-cpp">int main () &#123;
    int n;
    scanf(&quot;%d&quot;, &amp;n);
    double res = 1;
    for(int i = 0; i &lt;= n; i ++) &#123;
        res = min(res, 1.0 / (n * (n + 1 - i) * i));
    &#125;
    printf(&quot;%.9f&quot;, res);
&#125;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/gym/103470/problem/D">Paimon Sorting</a><br>题目大意: 给出一种$n^2$的排序方式, 询问数组长度为$k$时, 在排序的过程中交换了几次$k\in [1, n]$.<br>假设我们已经知道长度为$x$的结果, 那么怎么样可以推出$x + 1$的结果就是此题的关键. 设已经出现的最大值为$mx$, 考虑下面几种情况: $a[x] &lt; mx$; $a[x] = mx$; $a[x] &gt; mx$.<br>首先考虑第一种情况, 注意到该排序每轮是将最大值交换到$i$位置, 因此对于这种情况只需要考虑最后一轮, 从$1$到$x$位置,每次遇到大于$a[x]$的数便交换, 实际交换的次数为大于$a[x]$的数的集合的大小.<br>其次考虑第三种情况, 首先$a[x]$会走所有前一个最大值所有经过的路径, 此过程的价值为$0$, 其次$a[x]$ 会被移动到$1$位置, 再被移动到$x$位置, 此段的价值为 $2$.<br>最后考虑第二中情况, 显然它本身的价值应该为$0$, 但是它会对下一个 mx 移动到末位置产生阻碍(增加那一段的价值).这段增量为此时的位置到下一个mx位置的长度.</p>
<p>参考代码:</p>
<pre><code class="lang-cpp">struct BIT &#123;
    int N;
    vector&lt;int&gt; c;
    BIT(int n) &#123;
        N = n;
        c.resize(N);
    &#125;;
    void add(int x) &#123;
        for(int i = x; i &lt; N; i += (i &amp; (-i))) &#123;
            c[i] += 1;
        &#125;
    &#125;
    ll sum(int x) &#123;
        ll res = 0;
        for(int i = x; i; i -= (i &amp; (-i))) &#123;
            res += c[i];
        &#125;
        return res;
    &#125;
    ll sum(int l, int r) &#123;
        return sum(r) - sum(l - 1);
    &#125;
&#125;;
void solve() &#123;
    int n;
    cin &gt;&gt; n;
    vector&lt;int&gt; a(n);
    for(int i = 0; i &lt; n; i ++) &#123;
        cin &gt;&gt; a[i];
    &#125;
    ll res = 0;
    BIT bit(n + 10);
    vector&lt;int&gt; tol(n + 1);
    int len = -2;
    int mx = 0;
    for(int i = 0; i &lt; n; i ++) &#123;
        if(mx &lt; a[i]) &#123;
            res += 2 + len;
            mx = a[i];
            len = 0;
        &#125; else if(mx == a[i]) &#123;
            len ++;
        &#125; else &#123;
            if(len) len ++;
        &#125;
        res += bit.sum(a[i] + 1, n + 5);
        if(!tol[a[i]]) &#123;
            tol[a[i]] = 1;
            bit.add(a[i]);
        &#125;
        cout &lt;&lt; res;
        if(i == n - 1) &#123;
            cout &lt;&lt; &#39;\n&#39;;
        &#125; else &#123;
            cout &lt;&lt; &#39; &#39;;
        &#125;
    &#125;
&#125;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/gym/104114/problem/E">Exercise</a><br>题目大意: 给定$2n$个数, 原本(1, 2), (3, 4) … 是一组, 现在要重新分组, 但不能维持原来的组, 问重新分组后每组两个值差的绝对值和的最小值.<br>显然从小到大排序之后, 相邻的两个数分为一个组会使得绝对值和最小, 但不一定符合条件, 于是我们希望能通过某种方法使得所有不合法的组都合法.<br>发现需要被最优的重组方式一定是与相邻的组进行重组, 且增量为$2(p<em>{i + 1,l} - p</em>{i,r})$.<br>可以考虑一种这样的DP, $dp_{i,j}$, 其中$i$表示考虑到第$i$组, $j$表示该组是否需要被重组.<br>可以写出转移方程: </p>
<script type="math/tex; mode=display">
\begin{matrix}
    dp_{i, 1} = dp_{i-1, 0}\\
    dp_{i, 0} = min(dp_{i-1,0},\ dp_{i,0},\ dp_{i,1} + 2(p_{i + 1,l} - p_{i,r}))
\end{matrix}</script><p>参考代码:</p>
<pre><code class="lang-cpp">const ll INF = (1ll &lt;&lt; 60);
struct PAIR &#123;
    ll l, r;
    bool bad = 0;
&#125;;
void solve() &#123;
    int n;
    cin &gt;&gt; n;
    vector&lt;PII&gt; a(2 * n);
    for(int i = 0; i &lt; 2 * n; i ++) &#123;
        cin &gt;&gt; a[i].first;
        a[i].second = i + 1;
    &#125;
    sort(a.begin(), a.end());
    ll res = 0;
    vector&lt;PAIR&gt; p(n);
    for(int i = 0; i &lt; n; i ++) &#123;
        p[i].l = a[2 * i].first;
        p[i].r = a[2 * i + 1].first;
        res += p[i].r - p[i].l;
        int mx = max(a[2 * i].second, a[2 * i + 1].second);
        int mi = min(a[2 * i].second, a[2 * i + 1].second);
        if(mx - 1 == mi &amp;&amp; (mx % 2 == 0)) &#123;
            p[i].bad = 1;
        &#125;
    &#125;
    vector&lt;array&lt;ll, 2&gt;&gt; dp(n);
    dp[0][0] = dp[0][1] = INF;
    dp[0][p[0].bad] = 0;
    for(int i = 1; i &lt; n; i ++) &#123;
        dp[i][0] = dp[i][1] = INF;
        dp[i][p[i].bad] = dp[i - 1][0];
        dp[i][0] = min(dp[i][0], min(dp[i - 1][0], dp[i - 1][1]) + 2 * (p[i].l - p[i - 1].r));
    &#125;
    res += dp[n - 1][0];
    cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/gym/104114/problem/F">Fortune over Sportsmanship</a><br>题目大意: $n$人参见一个网球比赛, 一个$n\times n$的方格表示$(i, j)$进行比赛时收获的人气, 比赛总共进行$n - 1$轮, 胜方获得败方的人气(二者取max), 且败方淘汰出局.现在希望求出比赛可能收获的人气最大值, 并找出赛程.</p>
<p>考虑一种贪心的过程, 每次使当前状态下人气最大的两名选手进行比赛, 因为会继承败方的人气, 所以无论哪名选手淘汰都没关系. 可以用优先队列来模拟比赛.</p>
<p>参考代码:</p>
<pre><code class="lang-cpp">struct Z &#123;
    int val;
    int x, y;
    bool operator&lt; (const Z &amp;a) const &#123;
        if(val != a.val) &#123;
            return val &lt; a.val;
        &#125; else &#123;
            return x &lt; y;
        &#125;
    &#125;
&#125;;
void solve() &#123;
    int n;
    cin &gt;&gt; n;
    ll res = 0;
    vector&lt;vector&lt;int&gt;&gt; p(n, vector&lt;int&gt; (n));
    vector&lt;bool&gt; over(n);
    vector&lt;PII&gt; op;
    for(int i = 0; i &lt; n; i ++) &#123;
        for(int j = 0; j &lt; n; j ++) &#123;
            cin &gt;&gt; p[i][j];
        &#125;
    &#125;
    priority_queue&lt;Z&gt; q;
    for(int i = 0; i &lt; n; i ++) &#123;
        for(int j = i + 1; j &lt; n; j ++) &#123;
            q.push(&#123;p[i][j], i, j&#125;);
        &#125;
    &#125;
    while(q.size()) &#123;
        int v = q.top().val;
        int x = q.top().x;
        int y = q.top().y;
        q.pop();
        if(!over[x] &amp;&amp; !over[y]) &#123;
            op.push_back(&#123;x, y&#125;);
            res += v;
            over[y] = 1;
            for(int i = 0; i &lt; n; i ++) &#123;
                if(over[i] || i == x) continue;
                p[i][x] = p[x][i] = max(p[x][i], p[y][i]);
                q.push(&#123;p[x][i], min(x, i), max(x ,i)&#125;);
            &#125;
        &#125;
    &#125;
    cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
    for(auto &amp;[x, y] : op) &#123;
        cout &lt;&lt; x + 1 &lt;&lt; &#39; &#39; &lt;&lt; y + 1 &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1772/problem/G">Gaining Rating</a><br>题目大意: Monocarp 想提高自己在某下棋网站上的rating, 希望从$x$上升到$y$. 现在有$n$个对手, 每个对手有相应的rating $a_i$, rating 变化的规则为, 获胜加$1$, 失败减$1$但是对手的rating不变, Monocarp 只能下赢rating不大于自己的对手, 同时他可以自己挑选对手, 但是任意两个对手进行对弈的次数差不能大于$1$. 问需要多少轮才能达到目标或者说是不可能的.</p>
<p>显然, 首先需要对所有对手的rating进行一次排序. 我们考虑模拟一轮获得增量, 首先能够赢过$t$个人, 再败给$n-t$个人, 一轮总共获得的分数为$2t-n$, 如果距离所需达成的最终目标小于等于$t$时, 我们便可以不进入下一轮, 反之, 如果这一轮获得的分数小于等于$0$时, 无论如何都无法达到目标. 我们考虑如何求出$t$, 显然直接对$a$进行upper_bound是错误的, 因为我们的分数是在变化的. 可以考虑维护一个$b_i = a_i - i$表示想一路赢到$i$所需的最小rating. 但是这样的$b$不是单调的, 我们将不单调的$b_i$向下合并, 并增设权值, 这样我们得到了一个可以$log$求出$t$的数组.</p>
<pre><code class="lang-cpp">sort(a.begin(), a.end());
vector&lt;ll&gt; b = a;
for(int i = 0; i &lt; n; i ++) &#123;
    b[i] -= i;
&#125;
vector&lt;int&gt; s(1, 1);
vector&lt;ll&gt; v(1, b[0]);
for(int i = 1; i &lt; n; i ++) &#123;
    if(b[i] &lt;= v.back()) &#123;
        s.back() ++;
    &#125; else &#123;
        v.push_back(b[i]);
        s.push_back(1);
    &#125;
&#125;
v.push_back(1e18);
for(int i = 1; i &lt; s.size(); i ++) &#123;
    s[i] += s[i - 1];
&#125;
</code></pre>
<p>上述代码中$v$表示所说的单调数组, $s$表示增量, 接下来我们还不能一下子求出最后的答案, 我们将$v$中数值的大小视为分段的分界线, 已经知道了当前一轮所获得的增量, 我们要判断增量发生变化的值与$y-s_i$哪一个先到, 依次模拟每个分段便能求出最后的答案.</p>
<p>参考代码:</p>
<pre><code class="lang-cpp">void solve() &#123;
    int n;
    ll x, y;
    cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;
    vector&lt;ll&gt; a(n);
    for(int i = 0; i &lt; n; i ++) &#123;
        cin &gt;&gt; a[i];
    &#125;
    sort(a.begin(), a.end());
    vector&lt;ll&gt; b = a;
    for(int i = 0; i &lt; n; i ++) &#123;
        b[i] -= i;
    &#125;
    vector&lt;int&gt; s(1, 1);
    vector&lt;ll&gt; v(1, b[0]);
    for(int i = 1; i &lt; n; i ++) &#123;
        if(b[i] &lt;= v.back()) &#123;
            s.back() ++;
        &#125; else &#123;
            v.push_back(b[i]);
            s.push_back(1);
        &#125;
    &#125;
    v.push_back(1e18);
    for(int i = 1; i &lt; s.size(); i ++) &#123;
        s[i] += s[i - 1];
    &#125;
    for(int i = 1; i &lt; s.size(); i ++) &#123;
        s[i] += s[i - 1];
    &#125;
    ll res = 0;
    while(1) &#123;
        int i = upper_bound(v.begin(), v.end(), x) - v.begin();
        if(!i) &#123;
            cout &lt;&lt; -1 &lt;&lt; &#39;\n&#39;;
            return ;
        &#125;
        if(x + s[i - 1] &gt;= y) &#123;
            cout &lt;&lt; res + y - x &lt;&lt; &#39;\n&#39;;
            return ;
        &#125; else &#123;
            int add = 2 * s[i - 1] - n;
            if(add &lt;= 0) &#123;
                cout &lt;&lt; -1 &lt;&lt; &#39;\n&#39;;
                return;
            &#125; else &#123;
                ll ter = min(y - s[i - 1], v[i]);
                ll cnt = (teg - x + add - 1) / add;
                res += cnt * n;
                x += cnt * add;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1754/problem/F">https://codeforces.com/contest/1754/problem/F</a><br><a target="_blank" rel="noopener" href="https://codeforces.com/contest/822/problem/C">https://codeforces.com/contest/822/problem/C</a><br><a target="_blank" rel="noopener" href="https://codeforces.com/contest/229/problem/D">https://codeforces.com/contest/229/problem/D</a><br><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1288/problem/D">https://codeforces.com/contest/1288/problem/D</a><br><a target="_blank" rel="noopener" href="https://codeforces.com/gym/104114/problem/G">https://codeforces.com/gym/104114/problem/G</a><br><a target="_blank" rel="noopener" href="https://codeforces.com/gym/103446/problem/J">https://codeforces.com/gym/103446/problem/J</a><br><a target="_blank" rel="noopener" href="https://codeforces.com/gym/103470/problem/I">https://codeforces.com/gym/103470/problem/I</a></p>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/gym/103447/problem/G">https://codeforces.com/gym/103447/problem/G</a><br><a target="_blank" rel="noopener" href="https://codeforces.com/gym/104023/problem/J">https://codeforces.com/gym/104023/problem/J</a><br><a target="_blank" rel="noopener" href="https://codeforces.com/gym/104023/problem/D">https://codeforces.com/gym/104023/problem/D</a></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/%E9%A2%98%E8%A7%A3/" style="color: #03a9f4">题解</a>
        </span>
        
    </div>
    <a href="/2022/12/22/%E9%AB%98%E8%B4%A8%E9%87%8F%E9%A2%98%E8%A7%A3%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/11/28/Splay/">
        <h2 class="post-title">Splay</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                数据结构
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/11/28
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <pre><code class="lang-cpp">int root, tot;
const int MAXN = 1e5 + 10;
struct ND &#123;
    int ch[2],  // 儿子
        f,      // 父亲
        siz,    // 子树大小
        val,    // 值
        cnt;    // 个数
&#125; nd[MAXN];
void update(int x) &#123;
    nd[x].siz = nd[nd[x].ch[0]].siz + nd[nd[x].ch[1]].siz + nd[x].cnt;
&#125;
void rotate(int x) &#123;
    int y = nd[x].f;
    int z = nd[y].f;
    int k = nd[y].ch[1] == x;
    nd[z].ch[nd[z].ch[1] == y] = x;
    nd[x].f = z;
    nd[y].ch[k] = nd[x].ch[k ^ 1];
    nd[nd[x].ch[k ^ 1]].f = y;
    nd[x].ch[k ^ 1] = y;
    nd[y].f = x;
    update(y), update(x);
&#125;
void splay(int x, int goal) &#123;
    while(nd[x].f != goal) &#123;
        int y = nd[x].f;
        int z = nd[y].f;
        if(z != goal) &#123;
            (nd[z].ch[1] == y) == (nd[y].ch[1] == x) ?
                rotate(y) : rotate(x);
        &#125;
        rotate(x);
    &#125;
    if(goal == 0) &#123;
        root = x;
    &#125;
&#125;
void find(int x) &#123;
    int u = root;
    if(!u) &#123;
        return;
    &#125;
    while(nd[u].ch[x &gt; nd[u].val] &amp;&amp; x != nd[u].val) &#123;
        u = nd[u].ch[x &gt; nd[u].val];
    &#125;
    splay(u, 0);
&#125;
void insert(int x) &#123;
    int u = root, f = 0;
    while(u &amp;&amp; nd[u].val != x) &#123;
        f = u;
        u = nd[u].ch[x &gt; nd[u].val];
    &#125;
    if(u) &#123;
        nd[u].cnt ++;
    &#125; else &#123;
        u = ++ tot;
        if(f) &#123;
            nd[f].ch[x &gt; nd[f].val] = u;
        &#125;
        nd[u].ch[0] = nd[u].ch[1] = 0;
        nd[u].f = f;
        nd[u].val = x;
        nd[u].cnt = 1;
        nd[u].siz = 1;
    &#125;
    splay(u, 0);
&#125;
int Next(int x) &#123;
    find(x);
    int u = root;
    if(nd[u].val &gt; x) return u;
    u = nd[u].ch[1];
    while(nd[u].ch[0]) u = nd[u].ch[0];
    return u;
&#125;
int Pre(int x) &#123;
    find(x);
    int u = root;
    if(nd[u].val &lt; x) return u;
    u = nd[u].ch[0];
    while(nd[u].ch[1]) u = nd[u].ch[1];
    return u;
&#125;
void del(int x) &#123;
    int pre = Pre(x), next = Next(x);
    splay(pre, 0), splay(next, pre);
    int del = nd[next].ch[0];
    if(nd[del].cnt &gt; 1) &#123;
        nd[del].cnt --;
        splay(del, 0);
    &#125; else &#123;
        nd[next].ch[0] = 0;
    &#125;
&#125;
int kth(int k) &#123;
    int u = root;
    if(nd[u].siz &lt; k) &#123;
        return 0;
    &#125;
    while(1) &#123;
        int y = nd[u].ch[0];
        if(k &gt; nd[y].siz + nd[u].cnt) &#123;
            k -= nd[y].siz + nd[u].cnt;
            u = nd[u].ch[1];
        &#125; else &#123;
            if(k &lt;= nd[y].siz) &#123;
                u = y;
            &#125; else &#123;
                return nd[u].val;
            &#125;
        &#125;
    &#125;
&#125;
#include &lt;bits/stdc++.h&gt;
using namespace std;
int main() &#123;
    ios::sync_with_stdio(0), cin.tie(0);
    int q;
    cin &gt;&gt; q;
    insert(1e9), insert(-1e9);
    while(q --) &#123;
        int op, x;
        cin &gt;&gt; op &gt;&gt; x;
        switch (op) &#123;
            case 1:
                insert(x);
                break;
            case 2:
                del(x);
                break;
            case 3:
                find(x);
                cout &lt;&lt; nd[nd[root].ch[0]].siz &lt;&lt; &#39;\n&#39;;
                break;
            case 4:
                cout &lt;&lt; kth(x + 1) &lt;&lt; &#39;\n&#39;;
                break;
            case 5:
                cout &lt;&lt; nd[Pre(x)].val &lt;&lt; &#39;\n&#39;;
                break;
            case 6:
                cout &lt;&lt; nd[Next(x)].val &lt;&lt; &#39;\n&#39;;
                break;
        &#125;
    &#125;
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Splay/" style="color: #03a9f4">Splay</a>
        </span>
        
    </div>
    <a href="/2022/11/28/Splay/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/11/22/rust%E5%B0%8F%E8%AE%B0/">
        <h2 class="post-title">rust小记</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E8%83%BD/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                编程技能
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/11/22
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul>
<li>Linux<pre><code class="lang-shell">$ curl --proto &#39;=https&#39; --tlsv1.3 https://sh.rustup.rs -sSf | sh
</code></pre>
</li>
<li>windows<br>前往 <a target="_blank" rel="noopener" href="https://www.rust-lang.org/install.html">https://www.rust-lang.org/install.html</a> 并按照说明安装 Rust</li>
</ul>
<h3 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h3><pre><code class="lang-shell">$ rustc --version
</code></pre>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><pre><code class="lang-shell">$ rustup update
</code></pre>
<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><pre><code class="lang-shell">$ rustup self uninstall
</code></pre>
<h3 id="本地文档"><a href="#本地文档" class="headerlink" title="本地文档"></a>本地文档</h3><pre><code class="lang-shell">rustup doc
</code></pre>
<h2 id="编译命令与Cargo"><a href="#编译命令与Cargo" class="headerlink" title="编译命令与Cargo"></a>编译命令与Cargo</h2><h3 id="rustc"><a href="#rustc" class="headerlink" title="rustc"></a>rustc</h3><p>和gcc差不多的用法</p>
<pre><code class="lang-shell">$ rust [-g] &#123;filename.rs&#125; [-o]
</code></pre>
<h3 id="Cargo"><a href="#Cargo" class="headerlink" title="Cargo"></a>Cargo</h3><ul>
<li>创建一个项目<pre><code class="lang-shell">$ cargo new &#123;dirname&#125;
</code></pre>
</li>
<li>构建<pre><code class="lang-shell">$ cargo build [--release]
</code></pre>
只确保通过编译<pre><code class="lang-shell">cargo check
</code></pre>
</li>
<li>运行<pre><code class="lang-shell">$ cargo run
</code></pre>
</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>rust中变量默认设置为不可变, 只能被覆盖, 需要加<code>mut</code>前缀设置为可变.<br><code>const</code>修饰常量, 常量可以是个算式</p>
<h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><div class="table-container">
<table>
<thead>
<tr>
<th>长度</th>
<th>有符号</th>
<th>无符号</th>
</tr>
</thead>
<tbody>
<tr>
<td>8-bit</td>
<td><code>i8</code></td>
<td><code>u8</code></td>
</tr>
<tr>
<td>16-bit</td>
<td><code>i16</code></td>
<td><code>u16</code></td>
</tr>
<tr>
<td>32-bit</td>
<td><code>i32</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>64-bit</td>
<td><code>i64</code></td>
<td><code>u64</code></td>
</tr>
<tr>
<td>128-bit</td>
<td><code>i128</code></td>
<td><code>u128</code></td>
</tr>
<tr>
<td>arch</td>
<td><code>isize</code></td>
<td><code>usize</code></td>
</tr>
</tbody>
</table>
</div>
<p>向$0$取整</p>
<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p><code>f32</code>, <code>f64</code></p>
<h3 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h3><p><code>bool</code>: <code>enum &#123; true, false &#125;</code></p>
<h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><p>UTF-8编码(2-bit)<br><code>char</code></p>
<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p><code>(i32, i32, i32)</code><br><code>.</code>访问</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><code>[i32; 10]</code> $10$个<code>i32</code>变量</p>
<h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><pre><code class="lang-rust">enum IpAddr&#123;
    V4: (u8, u8, u8, u8),
    V6: String,
&#125;
</code></pre>
<p>枚举类型中的值是可选项，用<code>::</code>来构造一个实例</p>
<pre><code class="lang-rust">let home = IpAddr::V4(192, 0, 0, 10);
</code></pre>
<ul>
<li>特殊的枚举类型<code>Option</code><br>这是一个定义在标准库内的类型<pre><code class="lang-rust">enum Option&lt;T&gt; &#123;
  None,
  Some(T),
&#125;
</code></pre>
</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>无返回值 (void) 的函数</p>
<pre><code class="lang-rust">fn function() &#123;
    // -- skip -- 
&#125;
</code></pre>
<p>带返回值的函数</p>
<pre><code class="lang-rust">fn function() -&gt; i32 &#123;
    // 两中返回值的方式都是可以的
    5
    //return 5;
&#125;
</code></pre>
<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>兼容 C 风格, 可以带<code>()</code></p>
<pre><code class="lang-rust">if x &lt; 5 &#123;
    x += 1;
&#125; else if x &lt; 10 &#123;
    x += 2;
&#125; else &#123;
    x += 3;
&#125;
</code></pre>
<h3 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h3><p>无限循环体</p>
<pre><code class="lang-rust">loop &#123;
    x += 1;
    if x &gt;= 100 &#123;
        break;
    &#125;
&#125;
</code></pre>
<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>兼容 C 风格, 可以带<code>()</code></p>
<pre><code class="lang-rust">while x &lt; 5 &#123;
    x += 1;
&#125;
</code></pre>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>遍历集合</p>
<pre><code class="lang-rust">let a = [0, 1, 2, 3, 4, 5];
for i in a &#123;
    print!(&quot;&#123;&#125;&quot;, i);
&#125;
</code></pre>
<p>逆序遍历索引</p>
<pre><code class="lang-rust">for i in (0..5).rev() &#123;
    // --skip--
&#125;
</code></pre>
<h3 id="match"><a href="#match" class="headerlink" title="match"></a>match</h3><p>类似 C 语言中的switch</p>
<pre><code class="lang-rust">enum IpAddr &#123;
    V4(String),
    V6(String),
&#125;
let home = IpAddr::V4(String::from(&quot;192, 0, 0, 1&quot;));
let ip = match home &#123;
    IpAddr::V4(s) =&gt; &#123;
        s
    &#125;,
    IpAddr::V6(s) =&gt; s
    // =&gt; 表示产生的效果

    other =&gt; String::from(&quot;0, 0, 0, 0&quot;),
    //match 是穷尽的 
&#125;;
</code></pre>
<h3 id="if-let"><a href="#if-let" class="headerlink" title="if let"></a>if let</h3><p>弱化版的match</p>
<pre><code class="lang-rust">if let IpAddr::V4(s) = home&#123;
    println!(&quot;&#123;&#125;&quot;, s);
&#125; else &#123;
    cnt += 1;
&#125;
println!(&quot;&#123;&#125;&quot;, cnt);
</code></pre>
<h2 id="结构体定义与实例"><a href="#结构体定义与实例" class="headerlink" title="结构体定义与实例"></a>结构体定义与实例</h2><p>贴个自己写的 BIT 基本就会用了</p>
<pre><code class="lang-rust">fn  main () &#123;
    let mut bit = BIT::new(200);
    for i in (1..bit.N) &#123;
        bit.add(i, 1);
    &#125;
    for i in (1..bit.N) &#123;
        println!(&quot;&#123;&#125;&quot;, bit.sum(i));
    &#125;
&#125;
struct BIT &#123;
    N: i32,
    s: [i32; 1000],
&#125;
impl BIT &#123;
  // 类似构造方法
    fn new(n: i32) -&gt; Self &#123;
        let bit  =  Self &#123;
            N: n,
            s: [0; 1000],
        &#125;;
        bit
    &#125;
    fn add(&amp;mut self, x: i32, y: i32) &#123;
        let mut i = x;
        while i &lt; self.N &#123;
            let inx: usize = i.try_into().unwrap(); // 索引要转化成 usize
            self.s[inx] += y;
            i += i &amp; - i;
        &#125;
    &#125;
    fn sum(&amp;self, x: i32) -&gt; i32 &#123;
        let mut res = 0;
        let mut i = x;
        while i &gt; 0 &#123;
            let inx: usize = i.try_into().unwrap();
            res += self.s[inx];
            i -= i &amp; - i;
        &#125;
        res
    &#125;
&#125;
</code></pre>
<h2 id="几种常见的封装集合"><a href="#几种常见的封装集合" class="headerlink" title="几种常见的封装集合"></a>几种常见的封装集合</h2><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>定义</p>
<pre><code class="lang-rust">let v1 = vec![1, 2, 3, 4];
let v2 = vec![0; 5];
let  mut v3: Vec&lt;i32&gt; = Vec::new();
</code></pre>
<p>几个常用的函数</p>
<ul>
<li>push</li>
<li>pop</li>
<li>append<pre><code class="lang-rust">// 将 v2 中的元素移动到 v1
v1.append(&amp;mut v2);
</code></pre>
</li>
<li>sort | sort_by<pre><code class="lang-rust">// 逆序排序
v1.sort_by(|a, b| b.cmp(a));
</code></pre>
</li>
<li>is_empty</li>
<li>len</li>
<li>resize</li>
</ul>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>定义</p>
<pre><code class="lang-rust">let s1 = String::from(&quot;hello, &quot;);
let s2 = &quot;world!&quot;.to_string();
let s3 = s1 + &amp;s2;
</code></pre>
<p>采用 UTF-8 编码，利用索引引用的时候两个连续的索引表示一位<code>char</code>。</p>
<h3 id="Hash-Map"><a href="#Hash-Map" class="headerlink" title="Hash Map"></a>Hash Map</h3><p>定义</p>
<pre><code class="lang-rust">let mut map = HashMap::new();
map.insert(&quot;red&quot;.to_string(), 1);
map.insert(&quot;blue&quot;.to_string(), 2);
map.insert(&quot;red&quot;.to_string(), 10);  // 覆盖
map.entry(&quot;red&quot;.to_string()).or_insert(10); // 不存在则插入一个值
let conut = map.entry(&quot;bule&quot;.to_string()).or_insert(0);
*conut += 1; // 更新map中的数据
let x = map.get(&amp;&quot;red&quot;.to_string()).copied().unwrap_or(0); // 得到一个不可变的值
</code></pre>
<p>这个语言学了一半先咕咕了，暂时要搞点正事。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/rust/" style="color: #03a9f4">rust</a>
        </span>
        
    </div>
    <a href="/2022/11/22/rust%E5%B0%8F%E8%AE%B0/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/11/15/dp%E9%A2%98%E5%8D%95/">
        <h2 class="post-title">dp题单</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                做题记录
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/11/15
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>这里多数问题只做简单解释，对部分题目给出链接细说。</p>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1513/C">Add One</a><br><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1733/D2">Zero-One</a><br><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc271/tasks/abc271_e">Subsequence Path</a><br><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1740/problem/E">Hanging Hearts</a><br><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/abl/tasks/abl_d">Flat Subsequence</a><br><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc184/tasks/abc184_d">increment of coins</a></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="color: #00a596">动态规划</a>
        </span>
        
    </div>
    <a href="/2022/11/15/dp%E9%A2%98%E5%8D%95/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/10/30/%E6%A8%A1%E8%BF%90%E7%AE%97%E8%A7%84%E8%8C%83%E5%8F%8A%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E6%A8%A1%E6%9D%BF%E5%80%BC/">
        <h2 class="post-title">模运算规范及表达式求模板值</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/%E6%A8%A1%E6%9D%BF/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                模板
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/10/30
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h3 id="模运算规范，避免不必要的数值越界"><a href="#模运算规范，避免不必要的数值越界" class="headerlink" title="模运算规范，避免不必要的数值越界"></a>模运算规范，避免不必要的数值越界</h3><pre><code class="lang-cpp">const int mod = 998244353;
inline int add(int a,int b)&#123; return a + b &lt; mod ? a + b : a + b - mod;&#125;
inline int sub(int a,int b)&#123; return a &lt; b ? mod + a - b : a - b;&#125;
inline int mul(int a,int b)&#123; return 1ll * a * b % mod; &#125;
</code></pre>
<h3 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h3><pre><code class="lang-cpp">namespace CAL &#123;
    int expression(char*&amp;s);  // 计算一个不带括号的表达式值
    int token(char*&amp;s) &#123;      // 取出一个值加入到栈中
        if(*s == &#39;(&#39;) &#123;
            s ++;
            int ret = expression(s);
            s ++;
            return ret;
        &#125;
        int ret = 0;
        while(&#39;0&#39; &lt;= *s &amp;&amp; *s &lt;= &#39;9&#39;)&#123;
            ret = ret * 10 + *s++ - &#39;0&#39;;
        &#125;
        return ret % mod;
    &#125;
    int rank(char op) &#123;
        switch(op) &#123;
            case &#39;-&#39;: return 1;
            case &#39;+&#39;: return 1;
            case &#39;*&#39;: return 0;
        &#125;
        return 2;
    &#125;
    int expression(char*&amp;s)&#123;
        stack&lt;int&gt; svar;
        stack&lt;char&gt; sop;
        svar.push(token(s));
        while(true)&#123;
            char op = *s;
            if(!op || op == &#39;)&#39;) op = &#39;$&#39;;
            else s++;
            while(!sop.empty() &amp;&amp; rank(sop.top()) &lt;= rank(op))&#123;
                int b = svar.top();
                svar.pop();
                int a = svar.top();
                svar.pop();
                switch(sop.top())&#123;
                    case &#39;+&#39;:&#123;
                        svar.push(add(a, b));
                        break;
                    &#125;
                    case &#39;-&#39;:&#123;
                        svar.push(sub(a, b));
                        break;
                    &#125;
                    case &#39;*&#39;: &#123;
                        svar.push(mul(a, b));
                        break;
                    &#125;
                &#125;
                sop.pop();
            &#125;
            if(op == &#39;$&#39;) break;
            svar.push(token(s));
            sop.push(op);
        &#125;
        return svar.top();
    &#125;
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/%E6%A8%A1%E6%8B%9F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/" style="color: #03a9f4">模拟表达式求值</a>
        </span>
        
    </div>
    <a href="/2022/10/30/%E6%A8%A1%E8%BF%90%E7%AE%97%E8%A7%84%E8%8C%83%E5%8F%8A%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E6%A8%A1%E6%9D%BF%E5%80%BC/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/10/20/2022CCPC%E6%B2%B3%E5%8D%97%E7%9C%81%E8%B5%9B%E9%A2%98%E8%A7%A3/">
        <h2 class="post-title">2022CCPC河南省赛题解</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/%E9%A2%98%E8%A7%A3/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                题解
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/10/20
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p><a target="_blank" rel="noopener" href="https://codeforces.com/gym/103941">传送门</a></p>
<h3 id="A-Mocha-上小班啦"><a href="#A-Mocha-上小班啦" class="headerlink" title="A Mocha 上小班啦"></a>A Mocha 上小班啦</h3><p>签到，交换$01$位置输出即可。</p>
<pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
typedef pair&lt;int, int&gt; PII;
const int INF = 1e9 + 7, MAXN = 2e5 + 10, mod = 998244353;
string tab = &quot;1023456789&quot;;
int main() &#123;
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n;
    cin &gt;&gt; n;
    if(n &gt; tab.size()) &#123;
        cout &lt;&lt; &quot;-1\n&quot;;
    &#125; else &#123;
        for(int i = 0; i &lt; n; i ++) &#123;
            cout &lt;&lt; tab[i];
        &#125;
        cout &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;
</code></pre>
<h3 id="B-Hash"><a href="#B-Hash" class="headerlink" title="B Hash"></a>B Hash</h3><p>考虑子串的长度不大于$15$的情况(官方题解说只要考虑这种情况就行了)，然后dp就行了。只需证明长度为$16$的字串必然会存在一个划分使得产生的价值大于不划分产生的价值。具体看官方题解吧，这个证明我也说不太清（现场的话应该可以猜字串长度不会太大来做）。</p>
<pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
typedef pair&lt;int, int&gt; PII;
const int INF = 1e9 + 7, MAXN = 2e5 + 10, mod = 998244353;
int mp(char x) &#123;
    int res = 0;
    if(x == &#39;a&#39;) res = 1;
    else if(x == &#39;e&#39;) res = 2;
    else if(x == &#39;h&#39;) res = 3;
    else if(x == &#39;n&#39;) res = 4;
    return res;
&#125;
int main() &#123;
    ios::sync_with_stdio(false);
    cin.tie(0);
    string s;
    cin &gt;&gt; s;
    int n = s.size();
    s = s + s;
    vector&lt;ll&gt; d(16);
    for(int i = 0; i &lt; 16; i ++) &#123;
        if(!i) d[i] = 1;
        else d[i] = 31 * d[i - 1];
        d[i] %= mod;
    &#125;
    ll res = 0;
    for(int l = 1; l &lt;= 15; l ++) &#123;
        int r = l + n;
        vector&lt;ll&gt; dp (n + 1);
        for(int i = 1; i &lt;= n; i ++) &#123;
            ll t = 0;
            for(int j = i, x = 0; j &gt; max(0, i - 15); j --, x ++) &#123;
                t += mp(s[l + j - 1]) * d[x];
                t %= mod;
                dp[i] = max(dp[i], dp[j - 1] + t);
            &#125;
        &#125;
        res = max(res, dp[n]);
    &#125;
    cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre>
<h3 id="E-Serval-的俳句"><a href="#E-Serval-的俳句" class="headerlink" title="E Serval 的俳句"></a>E Serval 的俳句</h3><p>记录每个字母出现的位置，考虑三段组成的字母，第一段取字母的前5个并记录最后一个字母的位置，第二段找到从记录的位置开始，取7个，再记录最后一个字母的位置，第三段同理。时间复杂度$O(26^3log|S|)$。</p>
<pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
typedef pair&lt;int, int&gt; PII;
const int INF = 1e9 + 7, MAXN = 2e5 + 10, mod = 998244353;

int main() &#123;
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n;
    cin &gt;&gt; n;
    string s;
    cin &gt;&gt; s;
    vector&lt;vector&lt;int&gt;&gt; pos(26);
    for(int i = 0; i &lt; n; i ++) &#123;
        pos[s[i] - &#39;a&#39;].push_back(i);
    &#125;
    for(int i = 0; i &lt; 26; i ++) if(pos[i].size() &gt;= 5) &#123;
        int x1 = 4;
        for(int j = 0; j &lt; 26; j ++) &#123;
            int c = upper_bound(pos[j].begin(), pos[j].end(), pos[i][x1]) - pos[j].begin();
            if(pos[j].size() - c &lt; 7) &#123;
                continue;
            &#125;
            int x2 = c + 6;
            for(int k = 0; k &lt; 26; k ++) &#123;
                int c = upper_bound(pos[k].begin(), pos[k].end(), pos[j][x2]) - pos[k].begin();
                if(pos[k].size() - c &lt; 5) &#123;
                    continue;
                &#125;
                int x3 = c + 4;
                char x = &#39;a&#39; + i, y = &#39;a&#39; + j, z = &#39;a&#39; + k;
                for(int t = 0; t &lt; 5; t ++) &#123;
                    cout &lt;&lt; x;
                &#125;
                for(int t = 0; t &lt; 7; t ++) &#123;
                    cout &lt;&lt; y;
                &#125;
                for(int t = 0; t &lt; 5; t ++) &#123;
                    cout &lt;&lt; z;
                &#125;
                cout &lt;&lt; &#39;\n&#39;;
                return 0;
            &#125;

        &#125;
    &#125;
    cout &lt;&lt; &quot;none\n&quot;;
    return 0;
&#125;
</code></pre>
<h3 id="F-集合之和"><a href="#F-集合之和" class="headerlink" title="F 集合之和"></a>F 集合之和</h3><p>这题卡了很久，以为要求使$n$最小。。。<br>如果是一个等差数列的话，矩阵中的任意一点的值为$O(2a_0 + (i + j)k)$，发现$n$大小的数列能够产生$2n - 1$个不同的数，故对所有的奇数都成立。若前三个数不等差，那么会产生$6$个数，后面每多一个数与前一个数等差，会多产生两个数，故对于所有大于等于$6$的偶数都有解。</p>
<pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
typedef pair&lt;int, int&gt; PII;
const int INF = 1e9 + 7, MAXN = 2e5 + 10, mod = 998244353;

int main() &#123;
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n;
    cin &gt;&gt; n;
    if(n % 2 == 1) &#123;
        int x = (n + 1) / 2;
        cout &lt;&lt; x &lt;&lt; &#39;\n&#39;;
        for(int i = 1; i &lt;= x; i ++) &#123;
            cout &lt;&lt; i &lt;&lt; &#39; &#39;;
        &#125;
        cout &lt;&lt; &#39;\n&#39;;
    &#125; else &#123;
        if(n &gt;= 6) &#123;
            int x = n / 2;
            cout &lt;&lt; x &lt;&lt; &#39;\n&#39;;
            for(int i = 1, j = 1; j &lt;= x; i ++, j ++) &#123;
                if(i == 2) &#123;
                    i ++;
                &#125;
                cout &lt;&lt; i &lt;&lt; &#39; &#39;;
            &#125;
        &#125; else &#123;
            cout &lt;&lt; &quot;-1\n&quot;;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="G-Mocha-上大班啦"><a href="#G-Mocha-上大班啦" class="headerlink" title="G Mocha 上大班啦"></a>G Mocha 上大班啦</h3><p>诈骗题。&amp;运算只会使$0$减少，不会增加，那么对全部数进行&amp;运算就是求每一位都为$1$的个数。</p>
<pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
typedef pair&lt;int, int&gt; PII;
const int INF = 1e9 + 7, MAXN = 2e5 + 10, mod = 998244353;
int main() &#123;
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    vector&lt;vector&lt;int&gt;&gt; v(n, vector&lt;int&gt; (m));
    for(int i = 0; i &lt; n; i ++) &#123;
        string s;
        cin &gt;&gt; s;
        for(int j = 0; j &lt; m; j ++) &#123;
            v[i][j] = s[j] - &#39;0&#39;;
        &#125;
    &#125;
    struct OP &#123;
        int i, j, l, r, p;
    &#125;;
    int q;
    cin &gt;&gt; q;
    vector&lt;OP&gt; op(q);
    for(auto &amp;[i, j, l, r, p] : op) &#123;
        cin &gt;&gt; i &gt;&gt; j &gt;&gt; l &gt;&gt; r &gt;&gt; p;
    &#125;
    int res = 0;
    for(int i = 0; i &lt; m; i ++) &#123;
        int c = 1;
        for(int j = 0; j &lt; n; j ++) &#123;
            c &amp;= v[j][i];
        &#125;
        res += c;
    &#125;
    cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre>
<h3 id="H-旋转水管"><a href="#H-旋转水管" class="headerlink" title="H 旋转水管"></a>H 旋转水管</h3><p>dfs模拟，分类讨论即可, 根据当前位置的水管形状以及上一位置水管的方向来判断下一位置的方向, 时间复杂度$O(m)$。</p>
<pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
typedef pair&lt;int, int&gt; PII;
const int INF = 1e9 + 7, MAXN = 1e5 + 10, mod = 998244353;
int m, s, t;
char G[2][MAXN];
bool vis[3][MAXN];
/*
0 向下
1 向上
2 向左
3 向右
*/
bool res = 0;
void dfs(int x, int y, int type) &#123;
    if(vis[x][y]) &#123;
        return;
    &#125;
    if(x &lt; 0 || x &gt;= 2 || y &lt; 0 || y &gt;= m) &#123;
        if(x == 2 &amp;&amp; y == t) &#123;
            res = 1;
        &#125;
        return;
    &#125;
    vis[x][y] = 1;
    if(type == 1) &#123;
        if(G[x][y] == &#39;I&#39;) &#123;
            dfs(x + 1, y, type);
        &#125; else &#123;
            if(y &gt;= 1)
                dfs(x, y - 1, 2);
            dfs(x, y + 1, 3);
        &#125;
    &#125; else if(type == 2) &#123;
        if(G[x][y] == &#39;I&#39;) &#123;
            if(y &gt;= 1)
                dfs(x, y - 1, type);
        &#125; else &#123;
            if(x &gt;= 1)
                dfs(x - 1, y, 0);
            dfs(x + 1, y, 1);
        &#125;
    &#125; else if(type == 3) &#123;
        if(G[x][y] == &#39;I&#39;) &#123;
            dfs(x, y + 1, type);
        &#125; else &#123;
            if(x &gt;= 1)
                dfs(x - 1, y, 0);
            dfs(x + 1, y, 1);
        &#125;
    &#125; else &#123;
        if(G[x][y] == &#39;I&#39;) &#123;
            if(x &gt;= 1)
                dfs(x - 1, y, type);
        &#125; else &#123;
            if(y &gt;= 1)
                dfs(x, y - 1, 2);
            dfs(x, y + 1, 3);
        &#125;
    &#125;
    vis[x][y] = 0;
&#125;
void solve() &#123;
    cin &gt;&gt; m &gt;&gt; s &gt;&gt; t;
    s --, t --;
    for(int i = 0; i &lt; 2; i ++) &#123;
        for(int j = 0; j &lt; m; j ++) &#123;
            cin &gt;&gt; G[i][j];
        &#125;
    &#125;
    res = 0;
    dfs(0, s, 1);
    if(res) &#123;
        cout &lt;&lt; &quot;YES\n&quot;;
    &#125; else &#123;
        cout &lt;&lt; &quot;NO\n&quot;;
    &#125;
&#125;
int main() &#123;
    ios::sync_with_stdio(false);
    cin.tie(0);
    int _ = 1;
    cin &gt;&gt; _;
    while(_ --) &#123;
        solve();
    &#125;
    return 0;
&#125;
</code></pre>
<h3 id="I-Oshwiciqwq-的电梯"><a href="#I-Oshwiciqwq-的电梯" class="headerlink" title="I Oshwiciqwq 的电梯"></a>I Oshwiciqwq 的电梯</h3><p>大模拟，由于数据范围非常的小，可以确定每一秒的状态。</p>
<p>代码写得又臭又长，好在写了注释，应该可以看懂。</p>
<pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
typedef pair&lt;int, int&gt; PII;
const int INF = 1e9 + 7, MAXN = 2e5 + 10, mod = 998244353;
PII t[3][10][10];   // 0  X, 1  Y ,2  Z; first 位置， second 编号
int v[510];         // 0 未上电梯，1在x电梯上，2在y电梯上，3在z电梯上
struct P &#123;
    int tim;        // 出现时间
    int x, y, z;    // 当前位置
    int tx, ty, tz; // 目标位置
&#125; p[60]; 
int n, m, h, q, k;
void work() &#123;
    for(int i = 1; i &lt;= m; i ++) &#123;
        for(int j = 1; j &lt;= h; j ++) &#123;
            if(t[0][i][j].first &gt; 0) &#123;
                t[0][i][j].first %= n;
                t[0][i][j].first ++;
            &#125;
        &#125;
    &#125;
    for(int i = 1; i &lt;= n; i ++) &#123;
        for(int j = 1; j &lt;= h; j ++) &#123;
            if(t[1][i][j].first &gt;= 0) &#123;
                t[1][i][j].first %= m;
                t[1][i][j].first ++;
            &#125;
        &#125;
    &#125;
    for(int i = 1; i &lt;= n; i ++) &#123;
        for(int j = 1; j &lt;= m; j ++) &#123;
            if(t[2][i][j].first &gt;= 0) &#123;
                t[2][i][j].first %= h;
                t[2][i][j].first ++;
            &#125;
        &#125;
    &#125;
&#125;
struct RES &#123;
    int tt;
    int p;
    int io;
    int xl;
    int x, y, z;
    const bool operator &lt; (const RES&amp; a) const &#123;
        if(tt != a.tt) return tt &lt; a.tt;
        if(xl != a.xl) return xl &lt; a.xl;
        if(io != a.io) return io &lt; a.io;
        if(p != a.p) return p &lt; a.p;
    &#125;
&#125;;
vector&lt;RES&gt; res;
int main() &#123;
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; h &gt;&gt; k;
    for(int i = 0; i &lt; k; i ++) &#123;
        int type, ex, ey, ez;
        cin &gt;&gt; type &gt;&gt; ex &gt;&gt; ey &gt;&gt; ez;
        if(type == 0) &#123;
            t[type][ey][ez].first = ex;
            t[type][ey][ez].second = i;
        &#125; else if(type == 1) &#123;
            t[type][ex][ez].first = ey;
            t[type][ex][ez].second = i;
        &#125; else &#123;
            t[type][ex][ey].first = ez;
            t[type][ex][ey].second = i;
        &#125;
    &#125;
    cin &gt;&gt; q;
    for(int i = 0; i &lt; q; i ++) &#123;
        auto &amp;[tim, x, y, z, tx, ty, tz] = p[i];
        cin &gt;&gt; tim &gt;&gt; x &gt;&gt; y &gt;&gt; z &gt;&gt; tx &gt;&gt; ty &gt;&gt; tz;
    &#125;
    int tt = 0; // 当前时间戳
    bool ok = 0;
    do &#123;
        ok = 0;
        for(int i = 0; i &lt; q; i ++) &#123;
            if(p[i].tim &lt;= tt) &#123;
                // 未进电梯
                if(v[i] == 0) &#123;
                    if(p[i].x != p[i].tx) &#123;
                        ok = 1;
                        if(t[0][p[i].y][p[i].z].first == p[i].x) &#123;
                            res.push_back(&#123;tt, i + 1, 1 , t[0][p[i].y][p[i].z].second + 1, p[i].x, p[i].y, p[i].z&#125;);
                            v[i] = 1;
                            p[i].x %= n;
                            p[i].x ++;
                        &#125;
                    &#125; else if(p[i].y != p[i].ty) &#123;
                        ok = 1;
                        if(t[1][p[i].x][p[i].z].first == p[i].y) &#123;
                            res.push_back(&#123;tt, i + 1, 1 , t[1][p[i].x][p[i].z].second + 1, p[i].x, p[i].y, p[i].z&#125;);
                            v[i] = 2;
                            p[i].y %= m;
                            p[i].y ++;
                        &#125;
                    &#125; else if(p[i].z != p[i].tz) &#123;
                        ok = 1;
                        if(t[2][p[i].x][p[i].y].first == p[i].z) &#123;
                            res.push_back(&#123;tt, i + 1, 1 , t[2][p[i].x][p[i].y].second + 1, p[i].x, p[i].y, p[i].z&#125;);
                            v[i] = 3;
                            p[i].z %= h;
                            p[i].z ++;
                        &#125;
                    &#125;
                &#125; else if(v[i] == 1) &#123;
                    ok = 1;
                    if(p[i].x == p[i].tx) &#123;
                        res.push_back(&#123;tt, i + 1, 0, t[0][p[i].y][p[i].z].second + 1, p[i].x, p[i].y, p[i].z&#125;);
                        v[i] = 0;
                    &#125; else &#123;
                        p[i].x %= n;
                        p[i].x ++;
                    &#125;
                &#125; else if(v[i] == 2) &#123;
                    ok = 1;
                    if(p[i].y == p[i].ty) &#123;
                        res.push_back(&#123;tt, i + 1, 0, t[1][p[i].x][p[i].z].second + 1, p[i].x, p[i].y, p[i].z&#125;);
                        v[i] = 0;
                    &#125; else &#123;
                        p[i].y %= m;
                        p[i].y ++;
                    &#125;
                &#125; else if(v[i] == 3) &#123;
                    ok = 1;
                    if(p[i].z == p[i].tz) &#123;
                        res.push_back(&#123;tt, i + 1, 0, t[2][p[i].x][p[i].y].second + 1, p[i].x, p[i].y, p[i].z&#125;);
                        v[i] = 0;
                    &#125; else &#123;
                        p[i].z %= h;
                        p[i].z ++;
                    &#125;
                &#125;
            &#125; else &#123;
                ok = 1;
            &#125;
        &#125;
        work();
        tt ++;
    &#125; while (ok);
    sort(res.begin(), res.end());
    for(auto i : res) &#123;
        // [time] Person person_id IN / OUT Elevator elevator_id at (x, y, z);
        if(i.io == 1) &#123;
            cout &lt;&lt; &quot;[&quot; &lt;&lt; i.tt &lt;&lt; &quot;s] Person &quot; &lt;&lt; i.p &lt;&lt; &quot; IN Elevator &quot; &lt;&lt; i.xl &lt;&lt; &quot; at (&quot; &lt;&lt; i.x &lt;&lt; &quot;, &quot; &lt;&lt; i.y &lt;&lt; &quot;, &quot; &lt;&lt; i.z &lt;&lt; &quot;)\n&quot;;
        &#125; else &#123;
            cout &lt;&lt; &quot;[&quot; &lt;&lt; i.tt &lt;&lt; &quot;s] Person &quot; &lt;&lt; i.p &lt;&lt; &quot; OUT Elevator &quot; &lt;&lt; i.xl &lt;&lt; &quot; at (&quot; &lt;&lt; i.x &lt;&lt; &quot;, &quot; &lt;&lt; i.y &lt;&lt; &quot;, &quot; &lt;&lt; i.z &lt;&lt; &quot;)\n&quot;;

        &#125;
    &#125;
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/%E9%A2%98%E8%A7%A3/" style="color: #00a596">题解</a>
        </span>
        
    </div>
    <a href="/2022/10/20/2022CCPC%E6%B2%B3%E5%8D%97%E7%9C%81%E8%B5%9B%E9%A2%98%E8%A7%A3/" class="go-post">阅读全文</a>
</div>


        <div class="page-current">
    <div class="prev">
        
    </div>
    <div class="page-index">
        
        <span class="current">1</span>
        
        <span>
            <a class="page-num" href="/page/2/">2</a>
            
            
        </span>
        
    </div>
    <div class="next">
        
        <a class="page-num" href="/page/2/">
            <i class="fa-solid fa-caret-right fa-fw"></i>
        </a>
        
    </div>
</div>

    </div>
    
</div>

                    <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2023 - 2023 Muly&#39;s blog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;晓染
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

                </div>
            </transition>
            
        </div>
        <script src="/js/main.js"></script>
        
    </body>
</html>
